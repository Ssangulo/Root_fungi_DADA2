#Ecological analysis pipeline for paper


library(phyloseq)
library(microViz)
library(DECIPHER)
library(phangorn)
library(iNEXT.3D)
library(rlist)
library(vegan)
library(fantaxtic)
library(tidytree) #Need version 0.4.2 for functioning properly
library(ggplot2)
library(ggordiplots)
library(VennDiagram)
library(venn)
library(dplyr)
library(dada2)
library(ape)
library(picante)





np2 <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg2.poolps.rds")
np3 <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg3.poolps.rds")
np4 <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg4.poolps.rds")

np1.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/poolps.dada2.nosoil.rds")
np2.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg2.poolps_tax_nosoil.rds")
np3.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg3.poolps_tax_nosoil.rds")
np4.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg4.poolps_tax_nosoil.rds")

otu_tab<- otu_table(np2)  
dim(otu_tab)

new_metadata <- read.csv("/data/lastexpansion/danieang/data/trimmed/mergedPlates/ITS_metadata_Soil.csv", row.names = 1)

sample_data(np1) <- sample_data(new_metadata)
sample_data(np2) <- sample_data(new_metadata)
sample_data(np3) <- sample_data(new_metadata)
sample_data(np4) <- sample_data(new_metadata)

sample_data(np1.N) <- sample_data(new_metadata)
sample_data(np2.N) <- sample_data(new_metadata)
sample_data(np3.N) <- sample_data(new_metadata)
sample_data(np4.N) <- sample_data(new_metadata)


library(phyloseq)

alldat <- list(np1, np2, np3, np4) #Full dataset
alldat.N <- list(np1.N, np2.N, np3.N, np4.N) #root samples only, soil reads removed
alldat.root <- list(np1, np2, np3, np4) #root samples only, no remmoving soil reads

names(alldat) <- c("nofilt", "rg2", "rg3", "rg4")
names(alldat.N) <- c("nofilt", "rg2", "rg3", "rg4")
names(alldat.root) <- c("nofilt", "rg2", "rg3", "rg4")

#Removing 12 soil samples from list alldat.root
alldat.root <- lapply(alldat.root, function(ps_obj) {
  subset_samples(ps_obj, Individual != "S")
})


library(microViz)

alldat <- lapply(alldat, function(x) phyloseq_validate(x, remove_undetected = TRUE))
alldat.N <- lapply(alldat.N, function(x) phyloseq_validate(x, remove_undetected = TRUE))
alldat.root <- lapply(alldat.root, function(x) phyloseq_validate(x, remove_undetected = TRUE))


alldat
alldat.N



## Basic look at data
seqs <- rowSums(otu_table(np2.N))
min(colSums(otu_table(np2.N)))
otus <- apply(otu_table(np2.N), MARGIN=1, FUN=function(x) {length( x[x > 0] )} )
plot(seqs, otus)

### Some rarefaction to look at library depth adequacy
library(vegan)
ttab <- t(otu_table(np1))
class(ttab) <- "matrix" 
raremin <- min(rowSums(ttab))
rarecurve(ttab, step = 100, sample = raremin, col = "blue", label = FALSE)

### rareyfing data - but checking the minimum sequence count per smaple first sentence # samples are rows
min(rowSums(otu_table(alldat[[1]])))
min(rowSums(otu_table(alldat[[2]])))
min(rowSums(otu_table(alldat[[3]])))
min(rowSums(otu_table(alldat[[4]])))
## need to get rid of samples in the rg4 object with zero reads - removing 8 samples
k <- prune_samples(sample_sums(alldat[[4]]) > 0, alldat[[4]])
alldat[[4]] <- k

#Same process with Nosoil datasets
min(rowSums(otu_table(alldat.N[[1]])))
min(rowSums(otu_table(alldat.N[[2]])))
min(rowSums(otu_table(alldat.N[[3]])))
min(rowSums(otu_table(alldat.N[[4]])))
#Removing samples with zero reads in all 4 .N objects -> Removing 12 empty soil samples from each + unknown from np4.N
k1 <- prune_samples(sample_sums(alldat.N[[1]]) > 0, alldat.N[[1]])
alldat.N[[1]] <- k1
k2 <- prune_samples(sample_sums(alldat.N[[2]]) > 0, alldat.N[[2]])
alldat.N[[2]] <- k2
k3 <- prune_samples(sample_sums(alldat.N[[3]]) > 0, alldat.N[[3]])
alldat.N[[3]] <- k3
k4 <- prune_samples(sample_sums(alldat.N[[4]]) > 0, alldat.N[[4]])
alldat.N[[4]] <- k4 #Removed 10 more samples in this object



## checking again
min(rowSums(otu_table(alldat.root[[4]]))) #lame
hist(rowSums(otu_table(alldat[[4]]))) ## need to filter out samples with less than 100,000 sequences
k <- prune_samples(sample_sums(alldat[[4]]) > 100000, alldat[[4]])
alldat[[4]] <- k #Removed 11 samples
k3 <- prune_samples(sample_sums(alldat[[3]]) > 100000, alldat[[3]])
alldat[[3]] <- k3 #Removed 1 sample

k <- prune_samples(sample_sums(alldat.root[[4]]) > 100000, alldat.root[[4]])
alldat.root[[4]] <- k #Removed 7 samples

min(rowSums(otu_table(alldat.N[[4]]))) #11,516 for nosoil object -> filtering out samples with less than 100,000 seq
k4 <- prune_samples(sample_sums(alldat.N[[4]]) > 100000, alldat.N[[4]])
alldat.N[[4]] <- k4 #Removed 7 samples


rarfun  <- function(x) {
  rfy <- min(rowSums(otu_table(x)))
  sar.rats.rarefy <- rarefy_even_depth(x, sample.size=rfy, replace=FALSE, rngseed = 1)
  return(sar.rats.rarefy)
}

rfy <- min(rowSums(otu_table(alldat.root[[4]]))) 
alldat.root.rfy <- lapply(alldat.root, rarfun)

#Same process for nosoil objects
rarfun  <- function(x) {
  rfy <- min(rowSums(otu_table(x)))
  sar.rats.rarefy <- rarefy_even_depth(x, sample.size=rfy, replace=FALSE, rngseed = 1)
  return(sar.rats.rarefy)
}

rfy <- min(rowSums(otu_table(alldat.N[[4]])))
alldat.N.rfy <- lapply(alldat.N, rarfun)


## having a look at sample data summary
library(ggordiplots)
k <- as.data.frame(sample_data(alldat.root[[2]]))
head(k)
table(k$elevation_adj, k$site_elevation)
table(k$site,k$elevation_adj)

## Fixing tax tables by filling out N fields
alldat <- lapply(alldat, function(x) tax_fix(x,
                                             min_length = 3,
                                             unknowns = c(""),
                                             sep = " ", anon_unique = TRUE,
                                             suffix_rank = "classified"))


alldat.N <- lapply(alldat.N, function(x) tax_fix(x,
                                                 min_length = 3,
                                                 unknowns = c(""),
                                                 sep = " ", anon_unique = TRUE,
                                                 suffix_rank = "classified"))
alldat.root <- lapply(alldat.root, function(x) tax_fix(x,
                                                       min_length = 3,
                                                       unknowns = c(""),
                                                       sep = " ", anon_unique = TRUE,
                                                       suffix_rank = "classified"))



library(fantaxtic)

## labelling unique OTUslapply
alldat <- lapply(alldat, function(x) label_duplicate_taxa(x, "Species", duplicate_label = "<tax> <id>"))
head(tax_table(alldat[[2]]), n = 20)

alldat.N <- lapply(alldat.N, function(x) label_duplicate_taxa(x, "Species", duplicate_label = "<tax> <id>"))
head(tax_table(alldat.N[[2]]), n = 20)

alldat.root <- lapply(alldat.root, function(x) label_duplicate_taxa(x, "Species", duplicate_label = "<tax> <id>"))
head(tax_table(alldat.root[[2]]), n = 20)


save.image(file = "eco_analysis.RData")
load("eco_analysis.RData")

## having a look at sample data summary
k <- as.data.frame(sample_data(alldat.N[[2]]))
head(k)
table(k$site, k$habitat, k$elevation_adj)
table(k$site,k$elevation_adj)


NV_BEL_DOM <- subset_samples(alldat.N[[2]], site %in% c("NV","BEL","DOM"))
NV_BEL_DOM <- subset_samples(NV_BEL_DOM, !(site_elevation == "NV_4"))
NV_BEL_DOM <- subset_samples(NV_BEL_DOM, !(site_elevation == "BEL_3"))
NV_BEL_DOM <- prune_taxa(taxa_sums(NV_BEL_DOM) > 0, NV_BEL_DOM)

balanced_ps <- subset_samples(alldat.N[[2]], site %in% c("DOM", "NV"))
balanced_ps <- subset_samples(balanced_ps, !(site_elevation == "NV_4"))
balanced_ps <- prune_taxa(taxa_sums(balanced_ps) > 0, balanced_ps)  # Prune taxa with zero abundance


ps <- alldat.N[[2]]

## PCA on Aitchison distances (ecluidean distances from robust clr transformed data)
rfyrg2 <- decostand(otu_table(ps), "rclr", MARGIN=1)
my.rda <- rda(rfyrg2)
gdata <- sample_data(ps)
p <- gg_ordiplot(my.rda, groups = gdata$habitat, pt.size = 3, spiders = TRUE, ellipse = FALSE)

p <- gg_ordiplot(my.rda, groups = gdata$habitat, pt.size = 3, spiders = TRUE, ellipse = FALSE)
p <- p$plot
ggsave("/data/lastexpansion/danieang/Plots2/PCA_rg2N_site.png", plot = p, device = "png", width = 10, height = 6, dpi = 600)

# temporarily force a headless graphics device so gg_ordiplot doesn't try X11
old_dev <- getOption("device")
options(device = function(...) pdf(NULL))
on.exit(options(device = old_dev), add = TRUE)


#Visualizing sampling design

table(k$site, k$habitat)
table(k$elevation_adj,k$habitat)
table(k$habitat)


# Merging the two samples (replicates) from each individual (sum of OTU counts) for pseudoreplication-sensitive analyses: PERMANOVA, dbRDA, beta-regression and NRI/NTI
# Extract OTU table and sample data

ps <- alldat.N[[2]]

new_metadata <- read.csv("/data/lastexpansion/danieang/data/trimmed/mergedPlates/fix_metadata.csv",
                         row.names = 1)
sample_data(ps) <- sample_data(new_metadata)

# 1) OTU table as SAMPLES x TAXA (rows = samples, cols = OTUs)
otu_table_data <- otu_table(ps)
if (taxa_are_rows(ps)) otu_table_data <- t(otu_table_data)

# 2) Data frames
otu_table_df <- as.data.frame(otu_table_data, check.names = FALSE)
otu_table_df$SampleID <- rownames(otu_table_df)

sample_data_df <- data.frame(sample_data(ps), check.names = FALSE)
sample_data_df$SampleID <- rownames(sample_data_df)

# 3) Merge and remember which columns are OTUs
otu_cols <- setdiff(colnames(otu_table_df), "SampleID")

combined_df <- merge(
  otu_table_df,
  sample_data_df,
  by = "SampleID",
  all.x = TRUE
)

# be safe: OTU columns numeric
combined_df[otu_cols] <- lapply(combined_df[otu_cols], function(x) as.numeric(as.character(x)))

# 4) Sum OTUs by Unique_ID
summed_df <- combined_df |>
  dplyr::group_by(Unique_ID) |>
  dplyr::summarise(dplyr::across(dplyr::all_of(otu_cols), ~ sum(.x, na.rm = TRUE)),
                   .groups = "drop")

# 5) Keep ONE metadata row per Unique_ID, **excluding OTU columns**
first_sample_ids <- combined_df |>
  dplyr::group_by(Unique_ID) |>
  dplyr::summarise(dplyr::across(-dplyr::all_of(otu_cols), ~ dplyr::first(.x)),
                   .groups = "drop")

# 6) Join metadata + summed OTUs
final_df <- dplyr::left_join(first_sample_ids, summed_df, by = "Unique_ID")

# 7) Build matrices/metadata for phyloseq
otu_summed <- final_df |>
  dplyr::select(dplyr::all_of(otu_cols)) |>
  as.matrix()

# use Unique_ID as the collapsed sample name
rownames(otu_summed) <- final_df$Unique_ID

sample_metadata <- final_df |>
  dplyr::select(Unique_ID, site, site_elevation, habitat, treeline, Individual,
                elevation, elevation_adj) |>
  as.data.frame()

rownames(sample_metadata) <- sample_metadata$Unique_ID
sample_metadata$Unique_ID <- NULL

# 8) Make phyloseq (reuse taxonomy from ps if present)
otu_ps <- otu_table(otu_summed, taxa_are_rows = FALSE)
sample_ps <- sample_data(sample_metadata)

if (!is.null(tax_table(ps, errorIfNULL = FALSE))) {
  individual_ps <- phyloseq(otu_ps, sample_ps, tax_table(ps))
} else {
  individual_ps <- phyloseq(otu_ps, sample_ps)
}

# drop zero-sum taxa (optional, same as you did elsewhere)
individual_ps <- prune_taxa(taxa_sums(individual_ps) > 0, individual_ps)


individual_ps


#Making PERMANOVA and beta dispersion tests

ps <- individual_ps

dists <- vegdist(otu_table(ps), binary=FALSE, method="robust.aitchison") 
sampledf <- data.frame(sample_data(ps))
#sampledf$elevation_adj <- factor(sampledf$elevation_adj) # Convert elevation_adj to a factor

#adonis2(dists ~ elevation_adj, data = sampledf)
adonis2(dists ~ site * habitat, by = "terms", data = sampledf)


beta <- betadisper(dists, sampledf$habitat)
beta1 <- betadisper(dists, sampledf$site)

permutest(beta)
permutest(beta1)

#Running dbRDA with robust aitchison

d_ait <- vegdist(otu_table(ps), binary=FALSE, method="robust.aitchison")

sam <- data.frame(sample_data(ps))

sam$habitat <- factor(sam$habitat)  # levels inferred from data

## 1) dbRDA: habitat while conditioning on site
mod_ait <- capscale(d_ait ~ habitat + Condition(site), data = sam)

## 2) Permutation tests (for your Results text)
cat("\n== dbRDA overall ==\n")
print(anova.cca(mod_ait))                  # overall
cat("\n== dbRDA by term ==\n")
print(anova.cca(mod_ait, by = "terms"))    # habitat effect
cat("\n== dbRDA by axis ==\n")
print(anova.cca(mod_ait, by = "axis"))     # axes significance

## 3) % variance for the first two constrained axes (for axis labels)
eig_con <- mod_ait$CCA$eig
cap1_pct <- round(100 * eig_con[1] / sum(eig_con), 1)
cap2_pct <- round(100 * eig_con[2] / sum(eig_con), 1)

xlab_txt <- paste0("dbRDA1 (", cap1_pct, "%)")
ylab_txt <- paste0("dbRDA2 (", cap2_pct, "%)")

png("/data/lastexpansion/danieang/Plots2/dbRDA_plot1.png",
    width = 7.5, height = 6.5, units = "in", res = 600)

par(mfrow = c(1,1), mar = c(4,4,1,1), xpd = NA, cex = 1)

# Colors and shapes
cols <- c("forest" = "#1f77b4", "subparamo" = "#2ca02c", "paramo" = "#d62728")
pchv <- c("forest" = 16, "subparamo" = 17, "paramo" = 15)

# Empty plot, suppress auto axes and labels
plot(mod_ait, display = c("sites","cn"), type = "n",
     xaxt="n", yaxt="n", xlab="", ylab="")

# Draw points
with(sam, points(scores(mod_ait, display="sites"),
                 col = cols[habitat], pch = pchv[habitat], cex = 0.6))

# Bigger ellipses (1 SD, 95% CI)
with(sam, ordiellipse(mod_ait, habitat, kind="sd", level=0.95,
                      draw="polygon",
                      col = adjustcolor(unname(cols[levels(habitat)]), alpha.f=0.2),
                      border = unname(cols[levels(habitat)]), lwd=1.2))

# Centroids
cen <- with(sam, ordiellipse(mod_ait, habitat, kind="sd", level=0.95, plot=FALSE))
cen_xy <- do.call(rbind, lapply(cen, `[[`, "centroid"))
points(cen_xy, pch = 4, cex = 1.2, lwd = 1.4, col = unname(cols[rownames(cen_xy)]))

# Legend
legend("topright", inset=0.01, bty="n",
       legend = c("Forest","Subpáramo","Páramo"),
       col = cols, pch = c(16,17,15), pt.cex=0.9, cex=0.9)

# Custom axis labels only
mtext("dbRDA1", side=1, line=2.5)
mtext("dbRDA2", side=2, line=2.5)

dev.off()



#PCoA on bray-curtos dissimilarities

ps <- alldat.N[[2]]

# 1) Data -> Bray-Curtis -> PCoA
mat <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) mat <- t(mat)
mat_rel <- vegan::decostand(mat, method = "total", MARGIN = 1)

bc  <- vegan::vegdist(mat_rel, method = "bray")
ord <- vegan::capscale(bc ~ 1)

# % variance (clip negatives for non-Euclidean metrics)
eig  <- pmax(ord$CA$eig, 0)
ax1p <- round(100 * eig[1] / sum(eig), 1)
ax2p <- round(100 * eig[2] / sum(eig), 1)

# 2) Site scores + metadata
sc <- as.data.frame(vegan::scores(ord, display = "sites", choices = 1:2, scaling = 1))
colnames(sc)[1:2] <- c("Axis1", "Axis2")
sc$sample <- rownames(sc)

meta <- as.data.frame(sample_data(ps))
meta$sample <- rownames(meta)
sc$habitat <- meta$habitat[match(sc$sample, meta$sample)]
sc$site    <- meta$site[match(sc$sample, meta$sample)]
sc$habitat <- droplevels(factor(sc$habitat))
sc$site    <- droplevels(factor(sc$site))

# 3) Centroids per habitat (for spider anchors)
cent <- aggregate(cbind(Axis1, Axis2) ~ habitat, data = sc, FUN = mean)
names(cent) <- c("habitat","cX","cY")
sc <- merge(sc, cent, by = "habitat", all.x = TRUE)

# 4) Plot with spiders (segments to centroid), color=habitat, shape=site
gp <- ggplot(sc, aes(Axis1, Axis2, colour = habitat, shape = site)) +
  # spider legs
  geom_segment(aes(xend = cX, yend = cY, group = interaction(habitat, sample)),
               alpha = 0.5, linewidth = 0.3, show.legend = FALSE) +
  # points
  geom_point(size = 3) +
  # centroid marks
  geom_point(data = cent, aes(x = cX, y = cY, colour = habitat),
             inherit.aes = FALSE, size = 3, shape = 4, stroke = 1) +
  coord_equal() +
  xlab(paste0("PCoA1 (", ax1p, "%)")) +
  ylab(paste0("PCoA2 (", ax2p, "%)")) +
  guides(colour = guide_legend(title = "Habitat", order = 1),
         shape  = guide_legend(title = "Site",    order = 2)) +
  theme_classic(base_size = 12)

ggsave("/data/lastexpansion/danieang/Plots2/PCoA_N2_noMA.png",
       plot = gp, width = 12, height = 8, dpi = 800)


#Phylogenetic diversity tree etc

# Create phylogenetic data with soils sequences from O_Helotiales -> screen helotiales

helotiales <- alldat[[2]]  %>% tax_select(tax_list = "o__Helotiales")

align <- AlignSeqs(DNAStringSet(refseq(helotiales)), anchor=NA)

phang_align <- phyDat(as(align, "matrix"), type="DNA")
dm <- dist.ml(phang_align)
treeNJ <- NJ(dm)
fit <- pml(treeNJ, data=phang_align)
fitGTR <- update(fit, k=4, inv=0.2)
fit <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE, optNni=FALSE, optBf=TRUE, optQ=TRUE, optEdge=TRUE, optRooted=FALSE, rearrangement = "stochastic", control = pml.control(trace = 0))

tree_data_helotiales <- merge_phyloseq(helotiales, fit$tree)

## tree_data_sebacinales

#PD tree with rg2 no soil dataset (soil reads removed)

align <- AlignSeqs(DNAStringSet(refseq(alldat.N[[2]])), anchor=NA)

phang_align <- phyDat(as(align, "matrix"), type="DNA")
dm <- dist.ml(phang_align)
treeNJ <- NJ(dm)
fit <- pml(treeNJ, data=phang_align)
fitGTR <- update(fit, k=4, inv=0.2)
fit <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE, optNni=FALSE, optBf=TRUE, optQ=TRUE, optEdge=TRUE, optRooted=FALSE, rearrangement = "stochastic", control = pml.control(trace = 0))

tree_data_rg2.N <- merge_phyloseq(alldat.N[[2]], fit$tree)

load("tree_data_rg2.N.RData")

#PD plots with iNEXT3D

tree_rg2.N #phyloseq obj with rg2 root no soil data
tree_alldat_rg2 #phyloseq obj with rg2 alldata

ps <- tree_rg2.N 
## Correct mislabelled habitat: "pasture" -> "forest"
sd <- as.data.frame(sample_data(ps))

## replace values
sd$habitat <- as.character(sd$habitat)
sd$habitat[sd$habitat == "pasture"] <- "forest"

## assign back to ps
sample_data(ps)$habitat <- factor(sd$habitat)

## sanity: check after correction
cat("\nAfter correction:\n")
print(table(sample_data(ps)$habitat, useNA = "ifany"))


group_var <- "habitat"

# quick sanity
print(table(sample_data(ps)[[group_var]], useNA="ifany"))

# 1) incidence matrices: species (rows) x sampling-units (cols) per habitat
X <- as(otu_table(ps), "matrix"); if (taxa_are_rows(ps)) X <- t(X)
sd <- as.data.frame(sample_data(ps))
inc_by_hab <- lapply(split(seq_len(nrow(X)), sd[[group_var]]), function(i){
  M <- t(X[i,,drop=FALSE]); M[] <- as.integer(M>0); M[rowSums(M)>0,,drop=FALSE]
})
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]

# 2) tree prep: prune to observed taxa, drop duplicate labels, root if needed
tr <- phy_tree(ps)
keep <- intersect(tr$tip.label, unique(unlist(lapply(inc_by_hab, rownames))))
stopifnot(length(keep) >= 2)
tr2 <- keep.tip(tr, keep)
if (any(duplicated(tr2$tip.label))) tr2 <- drop.tip(tr2, which(duplicated(tr2$tip.label)))
tr2$node.label <- NULL
if (!is.rooted(tr2)) tr2 <- midpoint(tr2)

# align matrices to final tips
tipset <- tr2$tip.label
inc_by_hab <- lapply(inc_by_hab, function(M) M[rownames(M) %in% tipset,,drop=FALSE])
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]

# 3) run PD (meanPD) with incidence_raw
out_PD <- iNEXT3D(
  data      = inc_by_hab,
  diversity = "PD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 200, 
  PDtree    = tr2,
  PDtype    = "meanPD"
)


#Running NRI/NTI
library(picante)

stopifnot(exists("ps"))
if (!exists("tr2")) {
  tr2 <- phy_tree(ps)
  if (!is.rooted(tr2)) {
    library(phangorn)
    tr2 <- midpoint(tr2)
  }
}

## 1) Build a samples x taxa abundance matrix, aligned to the tree tips
comm <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) comm <- t(comm)

# Keep only taxa present in the tree AND in the table
keep_taxa <- intersect(colnames(comm), tr2$tip.label)
comm <- comm[, keep_taxa, drop = FALSE]
tr2  <- ape::keep.tip(tr2, keep_taxa)

# Optional: drop ultra-rare taxa to stabilize nulls (tweak threshold to taste)
keep_taxa2 <- colSums(comm) >= 10
comm <- comm[, keep_taxa2, drop = FALSE]
tr2  <- ape::keep.tip(tr2, colnames(comm))

## 2) Metadata
md <- as(sample_data(ps), "data.frame")
md <- md %>% mutate(habitat = factor(habitat))

## 3) Compute phylogenetic distance matrix among taxa (tips)
dist_phy <- cophenetic(tr2)

## 4) Run null-model tests
set.seed(1)

# Abundance-weighted MPD/MNTD (often more stable for roots/mycobiomes)
mpd_aw  <- ses.mpd (comm, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = TRUE)
mntd_aw <- ses.mntd(comm, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = TRUE)

# Presence–absence versions (sometimes stronger elevation signal, but noisier)
comm_pa <- 1 * (comm > 0)
mpd_pa  <- ses.mpd (comm_pa, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = FALSE)
mntd_pa <- ses.mntd(comm_pa, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = FALSE)

# 0) Make sure md is aligned to comm (you already did this, keeping it)
md <- as.data.frame(md)
md <- md[rownames(comm), , drop = FALSE]

# 1) Build per-sample table and FIX rownames before cbind
out <- data.frame(
  sample = rownames(comm),
  NRI_aw  = -mpd_aw$mpd.obs.z,
  NTI_aw  = -mntd_aw$mntd.obs.z,
  NRI_pa  = -mpd_pa$mpd.obs.z,
  NTI_pa  = -mntd_pa$mntd.obs.z,
  stringsAsFactors = FALSE
)
rownames(out) <- out$sample  # <<< critical fix

# now this aligns correctly
out <- cbind(out, md[rownames(out), c("habitat","site"), drop = FALSE])

# 2) drop any rows with NA z-scores (can happen if a sample has <2 taxa after filtering)
out <- out[complete.cases(out[, c("NRI_aw","NTI_aw","NRI_pa","NTI_pa")]), ]
out$habitat <- droplevels(factor(out$habitat))
out$site    <- droplevels(factor(out$site))

# quick sanity checks
print(table(out$habitat, useNA="ifany"))
print(table(out$site, useNA="ifany"))

# 3) Habitat-level summaries
library(dplyr)
sum_hab <- out |>
  group_by(habitat) |>
  summarize(
    n = n(),
    NRI_aw_med = median(NRI_aw),  NRI_aw_IQR = IQR(NRI_aw),
    NTI_aw_med = median(NTI_aw),  NTI_aw_IQR = IQR(NTI_aw),
    NRI_pa_med = median(NRI_pa),  NRI_pa_IQR = IQR(NRI_pa),
    NTI_pa_med = median(NTI_pa),  NTI_pa_IQR = IQR(NTI_pa),
    .groups = "drop"
  )
print(sum_hab)

# 4) Simple models (primary = abundance-weighted)
m_NTI_aw <- lm(NTI_aw ~ habitat + site, data = out)
m_NRI_aw <- lm(NRI_aw ~ habitat + site, data = out)
anova(m_NTI_aw); anova(m_NRI_aw)
# If residuals look nasty, also do: kruskal.test(NTI_aw ~ habitat, data=out)

## 5) Assemble per-sample NRI/NTI tables
# NRI = −Z(MPD); NTI = −Z(MNTD)
out <- data.frame(
  sample = rownames(comm),
  NRI_aw  = -mpd_aw$mpd.obs.z,
  NTI_aw  = -mntd_aw$mntd.obs.z,
  NRI_pa  = -mpd_pa$mpd.obs.z,
  NTI_pa  = -mntd_pa$mntd.obs.z
)

out <- cbind(out, md[rownames(out), c("habitat","site"), drop = FALSE])

## 6) Quick habitat summaries (median and IQR are robust)
sum_hab <- out %>%
  group_by(habitat) %>%
  summarize(
    n = n(),
    NRI_aw_med = median(NRI_aw, na.rm=TRUE),
    NRI_aw_IQR = IQR(NRI_aw, na.rm=TRUE),
    NTI_aw_med = median(NTI_aw, na.rm=TRUE),
    NTI_aw_IQR = IQR(NTI_aw, na.rm=TRUE),
    NRI_pa_med = median(NRI_pa, na.rm=TRUE),
    NRI_pa_IQR = IQR(NRI_pa, na.rm=TRUE),
    NTI_pa_med = median(NTI_pa, na.rm=TRUE),
    NTI_pa_IQR = IQR(NTI_pa, na.rm=TRUE)
  )

print(sum_hab)




#now running UniFrac PERMANOVA on PD in same session

# Sync taxa between ps and tr2
ps_u <- prune_taxa(taxa_names(ps) %in% tr2$tip.label, ps)
# (Optional) if some tips exist in tree but not in OTU table, prune them from tree too:
tr2 <- keep.tip(tr2, taxa_names(ps_u))

# Ensure the tree is in ps_u
phy_tree(ps_u) <- tr2

# Sanity
stopifnot(!is.null(phy_tree(ps_u)))
stopifnot(is.rooted(phy_tree(ps_u)))

#computing unifrac weighted and unweighted
UFw  <- UniFrac(ps_u, weighted = TRUE,  normalized = TRUE, parallel = FALSE, fast = TRUE)
UFuw <- UniFrac(ps_u, weighted = FALSE, normalized = TRUE, parallel = FALSE, fast = TRUE)
md   <- as(sample_data(ps_u), "data.frame")

set.seed(1)
per_w  <- adonis2(as.dist(UFw)  ~ habitat + site, by = "terms", data = md, permutations = 9999)
per_uw <- adonis2(as.dist(UFuw) ~ habitat + site, by = "terms", data = md, permutations = 9999)

# Homogeneity of dispersion across habitats (cite or mention if unequal)
bd_w  <- betadisper(as.dist(UFw),  md$habitat);  bdw_a  <- anova(bd_w)
bd_uw <- betadisper(as.dist(UFuw), md$habitat);  bduw_a <- anova(bd_uw)

per_w; per_uw
bdw_a; bduw_a


#


################

#Taxonomic diversity analysis with iNEXT3D

ps <- alldat.N[[2]]

##  Sanity
stopifnot(inherits(ps, "phyloseq"))
if (is.null(sample_data(ps))) stop("sample_data(ps) missing.")
if (is.null(otu_table(ps)))  stop("otu_table(ps) missing.")
sd <- as.data.frame(sample_data(ps))
if (!"habitat" %in% names(sd)) stop("'habitat' not in sample_data.")

##  Build incidence matrices per habitat (species x sampling-unit, 0/1)
taxa_rows <- taxa_are_rows(ps)
OTU <- as(otu_table(ps), "matrix")
if (!taxa_rows) OTU <- t(OTU)

inc_by_hab <- lapply(split(rownames(sd), sd$habitat), function(samps){
  M <- OTU[, colnames(OTU) %in% samps, drop = FALSE]
  M[M > 0] <- 1
  storage.mode(M) <- "numeric"
  M
})

out_TD_1 <- iNEXT.3D::iNEXT3D(
  data      = inc_by_hab,
  diversity = "TD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 200
)

##  Relabel habitats  in the iNEXT3D object for clean legend/order
labs_map  <- c(forest = "Forest", subparamo = "Subpáramo", paramo = "Páramo")
lvl_order <- c("Forest", "Subpáramo", "Páramo")

.relabel <- function(df){
  if (!("Assemblage" %in% names(df))) return(df)
  df$Assemblage <- labs_map[df$Assemblage]
  df$Assemblage <- factor(df$Assemblage, levels = lvl_order)
  df
}
out_TD$TDInfo    <- .relabel(as.data.frame(out_TD$TDInfo))
out_TD$TDAsyEst  <- .relabel(as.data.frame(out_TD$TDAsyEst))
if (!is.null(out_TD$TDiNextEst)) {
  for (nm in names(out_TD$TDiNextEst)) {
    out_TD$TDiNextEst[[nm]] <- .relabel(as.data.frame(out_TD$TDiNextEst[[nm]]))
  }
}

## 
p_TD <- ggiNEXT3D(out_TD, type = 1, facet.var = "Order.q") +
  labs(x = "Sampling units") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title   = element_blank(),
    legend.title = element_blank()
  )

print(p_TD)

ggsave("/data/lastexpansion/danieang/Plots2/iNEXT_TD_by_habitat.png",
       p_TD, width = 10, height = 6, dpi = 800, bg = "white")






######Exploring these... but not using them
#Now extracting asymptotic estimates per site

library(purrr)

# Map iNEXT.3D TD labels -> Hill number q
.q_map <- c("Species richness" = 0, "Shannon diversity" = 1, "Simpson diversity" = 2)

extract_tdasy <- function(out, site) {
  stopifnot("TDAsyEst" %in% names(out))
  out$TDAsyEst %>%
    mutate(
      site = site,
      elevation = as.numeric(gsub("m", "", Assemblage)),
      q = .q_map[qTD],
      Estimate = TD_asy,
      LCL = qTD.LCL,
      UCL = qTD.UCL
    ) %>%
    select(site, elevation, q, Estimate, LCL, UCL) %>%
    arrange(q, elevation)
}

site_objs <- list(
  NV  = output_TD_inci_NV,
  DOM = output_TD_inci_DOM,
  BEL = output_TD_inci_BEL,
  MA  = output_TD_inci_MA
)

all_asym <- imap_dfr(site_objs, extract_tdasy) %>%
  mutate(
    q = factor(q, levels = c(0,1,2),
               labels = c("q = 0 (richness)", "q = 1 (Shannon)", "q = 2 (Simpson)"))
  )

#Plot diversity vs elevations 

p <- ggplot(all_asym, aes(x = Estimate, y = elevation, color = site, shape = site, group = site)) +
  geom_errorbarh(aes(xmin = LCL, xmax = UCL), height = 0) +
  geom_point(size = 3) +
  geom_line(linewidth = 0.8) +
  facet_wrap(~ q, scales = "free_x") +
  labs(
    x = "Asymptotic α-diversity (Hill numbers)",
    y = "Elevation (m)",
    title = "Asymptotic iNEXT (TD) across sites and elevations"
  ) +
  theme_minimal(base_size = 13) +
  scale_color_brewer(palette = "Dark2")

print(p)

ggsave("/data/lastexpansion/danieang/plots/inext_asymptotes_vs_elevation.png", p, width = 10, height = 6, dpi = 600)




#Trying different apporach - extracting asymptotes 
library(dplyr)
library(purrr)
library(ggplot2)

# --- 1) Extract asymptotes per site from TDAsyEst ---
extract_tdasy <- function(out, site) {
  out$TDAsyEst %>%
    transmute(
      site = site,
      elevation = as.numeric(gsub("[^0-9.]", "", Assemblage)),
      q = factor(qTD, levels = c("Species richness","Shannon diversity","Simpson diversity"),
                 labels = c("q = 0 (richness)", "q = 1 (Shannon)", "q = 2 (Simpson)")),
      Estimate = TD_asy,
      LCL = qTD.LCL, UCL = qTD.UCL
    ) %>%
    arrange(q, elevation)
}

site_objs <- list(
  NV  = output_TD_inci_NV,
  DOM = output_TD_inci_DOM,
  BEL = output_TD_inci_BEL,
  MA  = output_TD_inci_MA
)

all_asym <- imap_dfr(site_objs, extract_tdasy)

# --- 2) Plot: alpha diversity (x) vs elevation (y), with LOESS band + points/paths + point CIs ---
p <- ggplot(all_asym, aes(x = Estimate, y = elevation, color = site, group = site)) +
  # smooth curve per site within each q, with its CI band
  geom_smooth(aes(fill = site), method = "loess", se = TRUE, span = 0.8, alpha = 0.15, linewidth = 0.7) +
  # connect elevations within site (the "tending to asymptote" trajectory)
  geom_path(linewidth = 0.9) +
  # point-wise CI (horizontal) from iNEXT asymptotes
  geom_errorbarh(aes(xmin = LCL, xmax = UCL), height = 0) +
  geom_point(size = 3, shape = 21, fill = "white", stroke = 1) +
  facet_wrap(~ q, scales = "free_x") +
  labs(x = "Asymptotic α-diversity (Hill numbers)",
       y = "Elevation (m)",
       title = "α-diversity vs elevation (asymptotic iNEXT estimates with LOESS bands)") +
  theme_minimal(base_size = 13) +
  scale_color_brewer(palette = "Dark2") +
  guides(fill = "none")

print(p)
# Save with white background
# ggsave("/data/lastexpansion/danieang/plots/inext_alpha_vs_elev_loess.png", p, width=10, height=6, dpi=600, bg="white")
# ggsave("/data/lastexpansion/danieang/plots/inext_alpha_vs_elev_loess.pdf", p, width=10, height=6)




#Microviz tax barplot

filter_taxa_by_rank <- function(physeq_obj, rank_prefix = "^g__", exclude_term = "Incertae_sedis") {
  taxa_assigned <- grepl(rank_prefix, tax_table(physeq_obj)[, "Genus"])
  exclude_incertae_sedis <- !grepl(exclude_term, tax_table(physeq_obj)[, "Genus"])
  taxa_filtered <- taxa_assigned & exclude_incertae_sedis
  physeq_filtered <- prune_taxa(taxa_filtered, physeq_obj)
  return(physeq_filtered)
}

ps_filtered <- filter_taxa_by_rank(alldat.N[[2]])

# Clean taxonomic prefixes like o__, g__, etc.
tax_table(ps_filtered) <- apply(
  tax_table(ps_filtered), 2, function(x) gsub("^[a-z]__", "", x)
)

# Recode habitat labels
sample_data(ps_filtered)$habitat <- dplyr::recode(
  as.character(sample_data(ps_filtered)$habitat),
  "forest"    = "Forest",
  "subparamo" = "Subpáramo",
  "paramo"    = "Páramo",
  .default = NA_character_
)

# Order the factor levels
sample_data(ps_filtered)$habitat <- factor(
  sample_data(ps_filtered)$habitat,
  levels = c("Forest","Subpáramo","Páramo"),
  ordered = TRUE
)

# Barplot faceted by habitat, clean legend labels
p_phyla <- ps_filtered %>%
  comp_barplot(
    tax_level = "Phylum", n_taxa = 5, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat",
    merge_other = FALSE, other_name = "Other phyla"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )

# Save the plot
ggsave(
  "/data/lastexpansion/danieang/Plots2/Genus_barplot_N_habitat.png",
  plot = p, device = "png", width = 12, height = 8, dpi = 800
)


# Save the first plot
ggsave("/data/lastexpansion/danieang/Plots2/Order_barplot_N_habitat.png", plot = p, device = "png", width = 12, height = 8, dpi = 800)




#Function to filter taxa past certain taxa rank 
genus_assigned <- grepl("^g__", tax_table(alldat.root[[2]])[, "Genus"])  

alldatroot2_genus_subset <- prune_taxa(genus_assigned, alldat.root[[2]])
ntaxa(alldatroot2_genus_subset)

class_assigned <- grepl("^c__", tax_table(alldat.root[[2]])[, "Class"])  

alldatroot2_class_subset <- prune_taxa(class_assigned, alldat.root[[2]])
ntaxa(alldatroot2_class_subset)

png("/data/lastexpansion/danieang/plots/PCA_balanced_microviz.png", width = 12, height = 8, units = "in", res = 500)
p <- balanced_ps %>%
  tax_transform("clr", rank = "Species") %>%
  ord_calc() %>%
  ord_plot(color = "site", shape = "elevation_adj", size = 2) +
  scale_colour_brewer(palette = "Dark2")

print(p)

# Close the PNG device
dev.off()

