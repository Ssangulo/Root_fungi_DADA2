##PD analyses with iNEXT3D

#PD plots with iNEXT3D

tree_rg2.N #phyloseq obj with rg2 root no soil data
tree_alldat_rg2 #phyloseq obj with rg2 alldata
tree_

## Correct mislabelled habitat: "pasture" -> "forest"
sd <- as.data.frame(sample_data(ps))

## replace values
sd$habitat <- as.character(sd$habitat)
sd$habitat[sd$habitat == "pasture"] <- "forest"

## assign back to ps
sample_data(ps)$habitat <- factor(sd$habitat)

## sanity: check after correction
cat("\nAfter correction:\n")
print(table(sample_data(ps)$habitat, useNA = "ifany"))


group_var <- "habitat"

# quick sanity
print(table(sample_data(ps)[[group_var]], useNA="ifany"))

# 1) incidence matrices: species (rows) x sampling-units (cols) per habitat
X <- as(otu_table(ps), "matrix"); if (taxa_are_rows(ps)) X <- t(X)
sd <- as.data.frame(sample_data(ps))
inc_by_hab <- lapply(split(seq_len(nrow(X)), sd[[group_var]]), function(i){
  M <- t(X[i,,drop=FALSE]); M[] <- as.integer(M>0); M[rowSums(M)>0,,drop=FALSE]
})
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]

# 2) tree prep: prune to observed taxa, drop duplicate labels, root if needed
tr <- phy_tree(ps)
keep <- intersect(tr$tip.label, unique(unlist(lapply(inc_by_hab, rownames))))
stopifnot(length(keep) >= 2)
tr2 <- keep.tip(tr, keep)
if (any(duplicated(tr2$tip.label))) tr2 <- drop.tip(tr2, which(duplicated(tr2$tip.label)))
tr2$node.label <- NULL
if (!is.rooted(tr2)) tr2 <- midpoint(tr2)

# align matrices to final tips
tipset <- tr2$tip.label
inc_by_hab <- lapply(inc_by_hab, function(M) M[rownames(M) %in% tipset,,drop=FALSE])
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]

# 3) run PD (meanPD) with incidence_raw
out_PD <- iNEXT3D(
  data      = inc_by_hab,
  diversity = "PD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 50, #increase this for publication-ready
  PDtree    = tr2,
  PDtype    = "meanPD"
)


#PLOTING ETC...



#NOW Helotiales analysis
helotiales_root <- subset_samples(tree_data_helotiales, Individual != "S")
helotiales_root <- phyloseq_validate(helotiales_root, remove_undetected = TRUE)




#Publication-ready plots and PD summary tables with high nBoot

# ---- iNEXT.3D PD (meanPD) by habitat, high nboot, tree_rg2.N ----

## -------- config --------
nboot_hi   <- 500               # increase for publication
group_var  <- "habitat"
out_dir    <- "/data/lastexpansion/danieang"
plot_png   <- file.path(out_dir, "iNEXT_PD_by_habitat_highN.png")
plot_pdf   <- file.path(out_dir, "iNEXT_PD_by_habitat_highN.pdf")
excel_path <- file.path(out_dir, "PD_habitat_summary_highN.xlsx")
rds_path   <- file.path(out_dir, "out_PD_highN.rds")
log_head   <- function(x) cat("\n---", x, "---\n")

## -------- load object --------
ps <- tree_rg2.N   # make sure this exists in the R session if sourcing; if using Rscript, loadRDS() it
# If needed, uncomment and point to a saved RDS:
# ps <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg2.poolps_tax_nosoil_with_tree.rds")

## -------- quick sanity --------
stopifnot(inherits(ps, "phyloseq"))
if (is.null(sample_data(ps))) stop("sample_data(ps) is NULL.")
if (is.null(otu_table(ps)))  stop("otu_table(ps) is NULL.")
if (is.null(phy_tree(ps)))   stop("phy_tree(ps) is NULL (PD needs a tree).")
if (is.null(phy_tree(ps)$edge.length)) stop("Tree lacks branch lengths.")

log_head("Habitat counts (pre-fix)")
print(table(sample_data(ps)[[group_var]], useNA = "ifany"))

## -------- fix 'pasture' -> 'forest' (same as before) --------
sd <- as.data.frame(sample_data(ps))
sd[[group_var]] <- as.character(sd[[group_var]])
sd[[group_var]][sd[[group_var]] == "pasture"] <- "forest"
sample_data(ps)[[group_var]] <- factor(sd[[group_var]])

log_head("Habitat counts (post-fix)")
print(table(sample_data(ps)[[group_var]], useNA = "ifany"))

## -------- build incidence matrices per habitat --------
X <- as(otu_table(ps), "matrix"); if (taxa_are_rows(ps)) X <- t(X)
sd <- as.data.frame(sample_data(ps))

inc_by_hab <- lapply(split(seq_len(nrow(X)), sd[[group_var]]), function(i){
  M <- t(X[i,, drop = FALSE])            # species x samples
  M[] <- as.integer(M > 0)               # incidence
  M <- M[rowSums(M) > 0,, drop = FALSE]  # drop empty taxa
  if (any(duplicated(rownames(M)))) M <- rowsum(M, group = rownames(M)) # merge dup taxa names
  M
})
# drop empties
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]
stopifnot(length(inc_by_hab) >= 1)

## -------- tree prep: prune to observed taxa, de-dup labels, midpoint root --------
tr <- phy_tree(ps)
tax_union <- unique(unlist(lapply(inc_by_hab, rownames)))
keep <- intersect(tr$tip.label, tax_union)
stopifnot(length(keep) >= 2)

tr2 <- keep.tip(tr, keep)
if (any(duplicated(tr2$tip.label))) {
  tr2 <- keep.tip(tr2, tr2$tip.label[!duplicated(tr2$tip.label)])
}
tr2$node.label <- NULL
if (!is.rooted(tr2)) tr2 <- midpoint(tr2)
if (is.null(tr2$edge.length)) stop("Tree lost branch lengths during pruning?")

# align incidence to final tips
tips <- tr2$tip.label
inc_by_hab <- lapply(inc_by_hab, function(M) M[rownames(M) %in% tips,, drop = FALSE])
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]
stopifnot(length(inc_by_hab) >= 1)

## -------- run iNEXT.3D PD (meanPD), high nboot --------
log_head(sprintf("Running iNEXT3D PD with nboot = %d", nboot_hi))
out_PD <- iNEXT3D(
  data      = inc_by_hab,
  diversity = "PD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = nboot_hi,
  PDtree    = tr2,
  PDtype    = "meanPD"
)

saveRDS(out_PD, rds_path)
log_head(paste("Saved out_PD to", rds_path))

## -------- plot (size-based) --------
p_PD <- ggiNEXT3D(out_PD, type = 1, facet.var = "Order.q") +
  ggtitle(sprintf("iNEXT.3D PD (meanPD) by habitat â€“ nboot = %d", nboot_hi))
ggsave(plot_png, p_PD, width = 10, height = 6, dpi = 600)
ggsave(plot_pdf, p_PD, width = 10, height = 6)
log_head(paste("Saved plots to", plot_png, "and", plot_pdf))

## -------- Excel summary (PDInfo, PDAsyEst, coverage-standardized) --------
PDInfo <- as.data.frame(out_PD$PDInfo)
PDasy  <- as.data.frame(out_PD$PDAsyEst)
covTab <- as.data.frame(out_PD$PDiNextEst$coverage_based)
target_SC <- min(PDInfo[,"SC(T)"], na.rm = TRUE)

# map q
q_map <- c("q = 0 PD"=0, "q = 1 PD"=1, "q = 2 PD"=2, "q = 0 meanPD"=0, "q = 1 meanPD"=1, "q = 2 meanPD"=2)
PDasy$Order.q <- unname(q_map[PDasy$qPD])

# pick rows closest to common coverage per Assemblage x q
pick_rows <- do.call(rbind, lapply(split(covTab, covTab$Assemblage), function(df) {
  do.call(rbind, lapply(split(df, df$Order.q), function(dd) {
    dd$diff <- abs(dd$SC - target_SC)
    dd[which.min(dd$diff), , drop = FALSE]
  }))
}))
# normalize m column name
if ("mT" %in% names(pick_rows)) {
  pick_rows$m_units <- pick_rows$mT
} else if ("m" %in% names(pick_rows)) {
  pick_rows$m_units <- pick_rows$m
} else pick_rows$m_units <- NA_real_
names(pick_rows)[names(pick_rows)=="qPD"] <- "qPD_est"

# write Excel
wb <- createWorkbook()
addWorksheet(wb, "PDInfo")
writeData(wb, "PDInfo", PDInfo)
addWorksheet(wb, "PD_Asymptotic")
writeData(wb, "PD_Asymptotic", PDasy[order(PDasy$Order.q, PDasy$Assemblage), ])
addWorksheet(wb, "Coverage_standardized")
writeData(wb, "Coverage_standardized",
          data.frame(Target_SC_used_all_habitats = target_SC), startRow = 1, startCol = 1)
writeData(wb, "Coverage_standardized",
          pick_rows[order(pick_rows$Order.q, pick_rows$Assemblage),
                    c("Assemblage","Order.q","SC","m_units","Method","qPD_est","qPD.LCL","qPD.UCL","Reftime","Type")],
          startRow = 3, startCol = 1)
saveWorkbook(wb, excel_path, overwrite = TRUE)
log_head(paste("Saved Excel to", excel_path))

cat("\nDONE\n")
