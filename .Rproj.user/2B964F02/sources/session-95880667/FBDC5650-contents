

library(stringr)
library(abind)
library(tidyverse)
library(dada2) 
library(devtools)
install_github("tobiasgf/lulu")
library(lulu)
library(dplyr)
library(data.table)
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("phyloseq")
library(phyloseq)
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
library(ggplot2)

##loading objects in new working directory
setwd("/data/lastexpansion/danieang/data/trimmed/mergedPlates/")

P1seqtab <- readRDS("P1seqtab.rds")
P1seqtabPP <- readRDS("P1seqtabPP.rds")
P1seqtabpsPP <- readRDS("P1seqtabpsPP.rds")

P2seqtab <- readRDS("P2seqtab.rds")
P2seqtabPP <- readRDS("P2seqtabPP.rds")
P2seqtabpsPP <- readRDS("P2seqtabpsPP.rds")

P3seqtab <- readRDS("P3seqtab.rds")
P3seqtabPP <- readRDS("P3seqtabPP.rds")
P3seqtabpsPP <- readRDS("P3seqtabpsPP.rds")

P4seqtab <- readRDS("P4seqtab.rds")
P4seqtabPP <- readRDS("P4seqtabPP.rds")
P4seqtabpsPP <- readRDS("P4seqtabpsPP.rds")

# Merge sequence tables 
merged_seqtab <- mergeSequenceTables(P1seqtab, P2seqtab, P3seqtab, P4seqtab)
merged_seqtabPP <- mergeSequenceTables(P1seqtabPP, P2seqtabPP, P3seqtabPP, P4seqtabPP)
merged_seqtabpsPP <- mergeSequenceTables(P1seqtabpsPP, P2seqtabpsPP, P3seqtabpsPP, P4seqtabpsPP)

# Remove chimeras from merged sequence tables
merged_seqtab.nochim <- removeBimeraDenovo(merged_seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
dim(merged_seqtab.nochim)
#Identified 1420 bimeras out of 28364 input sequences.
#1066 26944

merged_seqtabPP.nochim <- removeBimeraDenovo(merged_seqtabPP, method="consensus", multithread=TRUE, verbose=TRUE)
dim(merged_seqtabPP.nochim)
#Identified 1112 bimeras out of 18427 input sequences
#1066 17315

merged_seqtabpsPP.nochim <- removeBimeraDenovo(merged_seqtabpsPP, method="consensus", multithread=TRUE, verbose=TRUE)
dim(merged_seqtabpsPP.nochim)
#Identified 1635 bimeras out of 28979 input sequences.
#1066 27344


## Moving to LULU curation

## getting sequences

uniquesToFasta(merged_seqtab.nochim, fout="/data/lastexpansion/danieang/data/trimmed/mergedPlates2/merged_seqtab.nochim.fasta", ids=paste0("OTU", seq(length(getSequences(merged_seqtab.nochim)))))
uniquesToFasta(merged_seqtabPP.nochim, fout="/data/lastexpansion/danieang/data/trimmed/mergedPlates2/merged_seqtabPP.nochim.fasta", ids=paste0("OTU", seq(length(getSequences(merged_seqtabPP.nochim)))))
uniquesToFasta(merged_seqtabpsPP.nochim, fout="/data/lastexpansion/danieang/data/trimmed/mergedPlates2/merged_seqtabpsPP.nochim.fasta", ids=paste0("OTU", seq(length(getSequences(merged_seqtabpsPP.nochim)))))

## Make LULU OTU tables (OTUs: rows, samples: columns)
nopool.lulu <- merged_seqtab.nochim
colnames(nopool.lulu) <- paste0("OTU", seq(length(getSequences(merged_seqtab.nochim))))
nopool.lulu <- t(nopool.lulu)

pool.lulu <- merged_seqtabPP.nochim
colnames(pool.lulu) <- paste0("OTU", seq(length(getSequences(merged_seqtabPP.nochim))))
pool.lulu <- t(pool.lulu)

pspool.lulu <- merged_seqtabpsPP.nochim
colnames(pspool.lulu) <- paste0("OTU", seq(length(getSequences(merged_seqtabpsPP.nochim))))
pspool.lulu <- t(pspool.lulu)

#Save workspace 
save.image(file = "ITS.RData")

# Summarize sequence lengths
sequence_lengths1 <- nchar(getSequences(merged_seqtab.nochim))
summary(sequence_lengths1)

sequence_lengths2 <- nchar(getSequences(merged_seqtabPP.nochim))
summary(sequence_lengths2)

sequence_lengths3 <- nchar(getSequences(merged_seqtabpsPP.nochim))
summary(sequence_lengths3)



########### THIS NEXT PART IN THE BASH TERMINAL WITH BLAST INSTALLED IN PATH (or conda environment)
################### 

#First produce a blast databases with the OTUs
makeblastdb -in merged_seqtab.nochim.fasta -parse_seqids -dbtype nucl
makeblastdb -in merged_seqtabPP.nochim.fasta -parse_seqids -dbtype nucl
makeblastdb -in merged_seqtabpsPP.nochim.fasta -parse_seqids -dbtype nucl

# Then blast the OTUs against the database
blastn -db merged_seqtab.nochim.fasta -outfmt '6 qseqid sseqid pident' -out NoPool_match_list.txt -qcov_hsp_perc 80 -perc_identity 84 -query merged_seqtab.nochim.fasta
blastn -db merged_seqtabPP.nochim.fasta -outfmt '6 qseqid sseqid pident' -out Pool_match_list.txt -qcov_hsp_perc 80 -perc_identity 84 -query merged_seqtabPP.nochim.fasta
blastn -db merged_seqtabpsPP.nochim.fasta -outfmt '6 qseqid sseqid pident' -out psPool_match_list.txt -qcov_hsp_perc 80 -perc_identity 84 -query merged_seqtabpsPP.nochim.fasta

### Now running LULU algorithm in R 
setwd("/data/lastexpansion/danieang/data/trimmed/mergedPlates/")
NoPool_match_list.txt <- read.table("NoPool_match_list.txt")
str(NoPool_match_list.txt)
str(npool.lulu)
Pool_match_list.txt <- read.table("Pool_match_list.txt")
psPool_match_list.txt <- read.table("psPool_match_list.txt")
nopool.nochim.curated_result <- lulu(as.data.frame(npool.lulu), NoPool_match_list.txt)
pool.nochim.curated_result <- lulu(as.data.frame(pool.lulu), Pool_match_list.txt)
pspool.nochim.curated_result <- lulu(as.data.frame(pspool.lulu), psPool_match_list.txt)

## Check out how many OTUs were collapsed:
print(paste0("Not Pooled: ", "OTUs after Lulu: ", nopool.nochim.curated_result$curated_count, " --- ", "OTUs before Lulu: ", nrow(nopool.nochim.curated_result$original_table)))
#"Not Pooled: OTUs after Lulu: 18927 --- OTUs before Lulu: 26944"

print(paste0("Pooled: ", "OTUs after Lulu: ", pool.nochim.curated_result$curated_count, " --- ", "OTUs before Lulu: ", nrow(pool.nochim.curated_result$original_table)))
#"Pooled: OTUs after Lulu: 13497 --- OTUs before Lulu: 17315"

print(paste0("PsudoPooled: ", "OTUs after Lulu: ", pspool.nochim.curated_result$curated_count, " --- ", "OTUs before Lulu: ", nrow(pspool.nochim.curated_result$original_table)))
#"PsudoPooled: OTUs after Lulu: 18922 --- OTUs before Lulu: 27344"


## Making sequence tables compatible with summary routines below...
## Making vector of row numbers of OTUs kept after curation - correspond to column numbers from the precurated data
rownames(nopool.nochim.curated_result$curated_table)

nopool.kept.otus <-  as.numeric(gsub("OTU", "", rownames(nopool.nochim.curated_result$curated_table), ignore.case =FALSE, perl = TRUE))
pool.kept.otus <-  as.numeric(gsub("OTU", "", rownames(pool.nochim.curated_result$curated_table), ignore.case =FALSE, perl = TRUE))
pspool.kept.otus <-  as.numeric(gsub("OTU", "", rownames(pspool.nochim.curated_result$curated_table), ignore.case =FALSE, perl = TRUE))

nopool.lulu <- t(nopool.nochim.curated_result$curated_table)
colnames(nopool.lulu) <- colnames(merged_seqtab.nochim[, nopool.kept.otus])
pool.lulu <- t(pool.nochim.curated_result$curated_table)
colnames(pool.lulu) <- colnames(merged_seqtabPP.nochim[, pool.kept.otus])
pspool.lulu <- t(pspool.nochim.curated_result$curated_table)
colnames(pspool.lulu) <- colnames(merged_seqtabpsPP.nochim[, pspool.kept.otus])

## now we have LULU curated dataframes. We will subtract the max # sequences in No Template Controls for each OTU from sample OTU

## Tidying up names (can be modified as needed to tidy any rownames)
name.change <- function(x) {
  rownames(x) <- gsub("_P4_r", "_P4r", rownames(x), ignore.case = FALSE, perl = TRUE)
  rownames(x) <- gsub("_P3_r", "_P3r", rownames(x), ignore.case = FALSE, perl = TRUE)
  rownames(x) <- gsub("_P2_r", "_P2r", rownames(x), ignore.case = FALSE, perl = TRUE)
  rownames(x) <- gsub("_P1_r", "_P1r", rownames(x), ignore.case = FALSE, perl = TRUE)
  return(x)
}


# Apply the name change function to the LULU curated data frames
nopool.lulu <- name.change(nopool.lulu)
pool.lulu <- name.change(pool.lulu)
pspool.lulu <- name.change(pspool.lulu)

#Check current rownames
print(rownames(nopool.lulu))
print(rownames(pool.lulu))
print(rownames(pspool.lulu))


library(stringr)

## Some summary info for the data to use later - can be modified as needed according to naming convention

index.info <- function(x){
  y <- data.frame(matrix(NA,    # Create empty data frame
                         nrow = nrow(x),
                         ncol = 0))
  y$rep <- str_sub(rownames(x), start= -1)
  y$sample <- str_sub(rownames(x),1,nchar(rownames(x))-2)
  #y$sample <- ifelse(startsWith(y$sample, "L2")==TRUE, substring(y$sample, 2), y$sample)
  y$full <- rownames(x)
  y$totseq <- rowSums(x)
  y$OTUs <- rowSums(x>0)
  return(y)
}

## getting summary info
nopool.lulu.index <- index.info(nopool.lulu)
pool.lulu.index <- index.info(pool.lulu)
pspool.lulu.index <- index.info(pspool.lulu)

## Stopping here. saving at: /data/lastexpansion/danieang/data/trimmed/mergedPlates2

save.image(file = "merged_ITS.RData")

#/data/lastexpansion/danieang/data/trimmed/mergedPlates2/merged_ITS.RDATA

## need to subtract equivalent OTU sequences from NTCs, extraction blanks, field blanks etc.

## subtracting largest NTC value from each OTU from all samples for that OTU
ntc.change <- function(x){
  mind <- apply(x[grep("PCRB", rownames(x)), ], 2, function(y) max(y, na.rm = TRUE))
  x1 <- sweep(x, 2, mind)
  x1 <- pmax(x1,0)
  return(x1)
}

##### removing NTC counts from each OTU using the highest sequencing count per OTU in the NTCs

nopool.lulu.ntc <-  ntc.change(nopool.lulu)
pool.lulu.ntc <-  ntc.change(pool.lulu)
pspool.lulu.ntc <-  ntc.change(pspool.lulu)

### Controlling for extraction blanks

## need experimental data
exdata <- read.csv("cleaned_merged_metadata.csv")
str(exdata)

## function to convert data to list of matrices split by blank extract batch
#Modify "sample.info.nopool" and "nopool.lulu.index" for each dataset!! 
#I am hardcoring each sample.info in each function, so each function must be used only with the correct object

ntc.to.blankcontrol <-  function (x){
  z <- x
  sample.info.nopool <- dplyr::bind_rows(nopool.lulu.index, .id = "column_label")
  row.names(sample.info.nopool) = sample.info.nopool$full
  z = merge(nopool.lulu.ntc, sample.info.nopool, by =  'row.names', all.x=TRUE)
  z = merge(z, exdata, by.x="sample", by.y="sample", all.x=TRUE)
  rownames(z) <- z$Row.names 
  z = split(z, z$extract_blank)
  dropnames <- colnames(z[[2]][, c(which(nchar(colnames(z[[2]]))< 30))])
  z <- lapply(z, function(x) x[!(names(x) %in% dropnames)])
  z = lapply(z, as.matrix)
  return(z)
}

nopool.lulu.ntc.blankC <- ntc.to.blankcontrol(nopool.lulu.ntc)
pool.lulu.ntc.blankC <- ntc.to.blankcontrol(pool.lulu.ntc)
pspool.lulu.ntc.blankC <- ntc.to.blankcontrol(pspool.lulu.ntc)

## getting rid of experimental controls with no blank samples
nopool.lulu.ntc.blankC1 <- nopool.lulu.ntc.blankC[-1]
pool.lulu.ntc.blankC1 <- pool.lulu.ntc.blankC[-1]
pspool.lulu.ntc.blankC1 <- pspool.lulu.ntc.blankC[-1]

unique(exdata$extract_blank) # copy in blank extract names
blank.change <- function(x){
  mind <- apply(x[grep("E_1_7|E_2_12|E_3_12|E_4_12|E_5_12|E_6_12|E_7_12|E_8_12|E_9_12|E_10_12|E_11_12|E_12_6|E_S1_8|E_S2_6|E_BC|E_W4", rownames(x)), ], 2, function(y) max(y, na.rm = TRUE))
  x1 <- sweep(x, 2, mind)
  x1 <- pmax(x1,0)
  return(x1)
}

nopool.lulu.ntc.blankC2 <- lapply(nopool.lulu.ntc.blankC1, blank.change)
pool.lulu.ntc.blankC2 <- lapply(pool.lulu.ntc.blankC1, blank.change)
pspool.lulu.ntc.blankC2 <- lapply(pspool.lulu.ntc.blankC1, blank.change)

## inf values because trying to subtract 0 from 0 .. converting back 

nopool.lulu.ntc.blankC2 <- lapply(nopool.lulu.ntc.blankC2,function(x) replace(x, !is.finite(x), 0))
pool.lulu.ntc.blankC2 <- lapply(pool.lulu.ntc.blankC2, function(x) replace(x, !is.finite(x), 0))
pspool.lulu.ntc.blankC2 <- lapply(pspool.lulu.ntc.blankC2, function(x) replace(x, !is.finite(x), 0))

########## 


##### The same can occur for field blanks - merging dataset again
nopool.lulu.ntc.blankC2 <- lapply(nopool.lulu.ntc.blankC2,function(x) as.data.frame(x))
pool.lulu.ntc.blankC2 <- lapply(pool.lulu.ntc.blankC2,function(x) as.data.frame(x))
pspool.lulu.ntc.blankC2 <- lapply(pspool.lulu.ntc.blankC2,function(x) as.data.frame(x))

nopool.lulu.ntc.blank.fieldb <- dplyr::bind_rows(nopool.lulu.ntc.blankC2, .id = "column_label")
pool.lulu.ntc.blank.fieldb <- dplyr::bind_rows(pool.lulu.ntc.blankC2, .id = "column_label")
pspool.lulu.ntc.blank.fieldb <- dplyr::bind_rows(pspool.lulu.ntc.blankC2, .id = "column_label")


## function to group samples into lists via field blanks
#Modify "sample.info.nopool" and "nopool.lulu.index" for each dataset!!

exblank.to.fieldblankcontrol <-  function (x){
  z <- x
  sample.info.nopool <- dplyr::bind_rows(nopool.lulu.index, .id = "column_label")
  row.names(sample.info.nopool) = sample.info.nopool$full
  z = merge(nopool.lulu.ntc, sample.info.nopool , by =  'row.names', all.x=TRUE)
  z = merge(z, exdata, by.x="sample", by.y="sample", all.x=TRUE)
  rownames(z) <- z$Row.names 
  z = split(z, z$Fieldcontrol)
  dropnames <- colnames(z[[2]][, c(which(nchar(colnames(z[[2]]))< 30))])
  z <- lapply(z, function(x) x[!(names(x) %in% dropnames)])
  z = lapply(z, as.matrix)
  return(z)
}


nopool.lulu.ntc.blank.fieldblist <- exblank.to.fieldblankcontrol(nopool.lulu.ntc.blank.fieldb)
pool.lulu.ntc.blank.fieldblist <- exblank.to.fieldblankcontrol(pool.lulu.ntc.blank.fieldb)
pspool.lulu.ntc.blank.fieldblist <- exblank.to.fieldblankcontrol(pspool.lulu.ntc.blank.fieldb)


## getting rid non-samples experimental controls with no blank samples ->  eliminate blank extraction controls

nopool.lulu.ntc.blank.fieldblist <- nopool.lulu.ntc.blank.fieldblist[-1]
pool.lulu.ntc.blank.fieldblist <- pool.lulu.ntc.blank.fieldblist[-1]
pspool.lulu.ntc.blank.fieldblist <- pspool.lulu.ntc.blank.fieldblist[-1]

#unique(exdata$Fieldcontrol) # copy in blank extract names

#lets skip this function because my soil samples are not field controls and normalizing here do not make sense

#fb.blank.change <- function(x){
 # mind <- apply(x[grep("S_S1_1|S_S1_2|S_S1_3|S_S1_4|S_S1_5|S_S1_6|S_S1_7|S_S2_1|S_S2_2|S_S2_3|S_S2_4|S_S2_5", rownames(x)), ], 2, function(y) max(y, na.rm = TRUE))
  #x1 <- sweep(x, 2, mind)
  #x1 <- pmax(x1,0)
 # return(x1)
#}

#nopool.lulu.ntc.blank.fieldblist1 <- lapply(nopool.lulu.ntc.blank.fieldblist, fb.blank.change)
#pool.lulu.ntc.blank.fieldblist1 <- lapply(pool.lulu.ntc.blank.fieldblist, fb.blank.change)
#pspool.lulu.ntc.blank.fieldblist1 <- lapply(pspool.lulu.ntc.blank.fieldblist, fb.blank.change)

nopool.lulu.ntc.blank.fieldblist1 <- lapply(nopool.lulu.ntc.blank.fieldblist,function(x) replace(x, !is.finite(x), 0))
pool.lulu.ntc.blank.fieldblist1 <- lapply(pool.lulu.ntc.blank.fieldblist, function(x) replace(x, !is.finite(x), 0))
pspool.lulu.ntc.blank.fieldblist1 <- lapply(pspool.lulu.ntc.blank.fieldblist, function(x) replace(x, !is.finite(x), 0))

## Merging data back to just biological samples
##### The same can occur for field blanks - merging dataset again
nopool.lulu.ntc.blank.fieldblist1 <- lapply(nopool.lulu.ntc.blank.fieldblist1,function(x) as.data.frame(x))
pool.lulu.ntc.blank.fieldblist1 <- lapply(pool.lulu.ntc.blank.fieldblist1,function(x) as.data.frame(x))
pspool.lulu.ntc.blank.fieldblist1 <- lapply(pspool.lulu.ntc.blank.fieldblist1,function(x) as.data.frame(x))


nopool.lulu.ntc.blank.fielddone<- dplyr::bind_rows(nopool.lulu.ntc.blank.fieldblist1, .id = "column_label")

pool.lulu.ntc.blank.fielddone<- dplyr::bind_rows(pool.lulu.ntc.blank.fieldblist1, .id = "column_label")

pspool.lulu.ntc.blank.fielddone<- dplyr::bind_rows(pspool.lulu.ntc.blank.fieldblist1, .id = "column_label")

#removing column id labels
nopool.lulu.ntc.blank.fielddone<- nopool.lulu.ntc.blank.fielddone[,-1]
pool.lulu.ntc.blank.fielddone<- pool.lulu.ntc.blank.fielddone[,-1]
pspool.lulu.ntc.blank.fielddone<-  pspool.lulu.ntc.blank.fielddone[,-1]

## need to remove non-biological samples from dataframes and split into lists of individual samples for replicate control and combination etc

unique(rownames(nopool.lulu.ntc.blank.fielddone))

#Here as I do not have any sample named with "fb" this function is not removing my samples!
controlledblanks.to.samplelist <-  function (x){
  minusNTCBLANK.sample <- x
  minusNTCBLANK.sample <- minusNTCBLANK.sample[!grepl("fb", rownames(minusNTCBLANK.sample)),]
  minusNTCBLANK.sample <-  merge(minusNTCBLANK.sample, sample.info.nopool ,by =  'row.names', all.x=TRUE)
  rownames(minusNTCBLANK.sample) <- minusNTCBLANK.sample$Row.names
  minusNTCBLANK.sample <- split(minusNTCBLANK.sample, minusNTCBLANK.sample$sample)
  dropnames <- colnames(minusNTCBLANK.sample[[2]][, c(which(nchar(colnames(minusNTCBLANK.sample[[2]]))< 30))])
  minusNTCBLANK.sample <- lapply(minusNTCBLANK.sample, function(x) x[!(names(x) %in% dropnames)])
  return(minusNTCBLANK.sample)
}
controlledblanks.to.samplelist <- function(x) {
  # Hardcoding sample.info.nopool inside the function
  sample.info.nopool <- dplyr::bind_rows(nopool.lulu.index, .id = "column_label")
  row.names(sample.info.nopool) <- sample.info.nopool$full
  
  # Processing the input dataset
  minusNTCBLANK.sample <- x
  minusNTCBLANK.sample <- merge(minusNTCBLANK.sample, sample.info.nopool, by = "row.names", all.x = TRUE)
  rownames(minusNTCBLANK.sample) <- minusNTCBLANK.sample$Row.names
  
  # Split by sample and drop unnecessary columns
  minusNTCBLANK.sample <- split(minusNTCBLANK.sample, minusNTCBLANK.sample$sample)
  dropnames <- colnames(minusNTCBLANK.sample[[2]][, c(which(nchar(colnames(minusNTCBLANK.sample[[2]])) < 30))])
  minusNTCBLANK.sample <- lapply(minusNTCBLANK.sample, function(x) x[!(names(x) %in% dropnames)])
  
  return(minusNTCBLANK.sample)
}

nopool.lulu.controlled_1 <- controlledblanks.to.samplelist(nopool.lulu.ntc.blank.fielddone)
pool.lulu.controlled_1 <- controlledblanks.to.samplelist(pool.lulu.ntc.blank.fielddone)
pspool.lulu.controlled_1 <-  controlledblanks.to.samplelist(pspool.lulu.ntc.blank.fielddone)


## if you view just these raw data, some samples and some replicates did not sequence well  

View()

## so there is the "raw" data that can be combined (no PCR replicate filtering) - no filtering at all required.
## and then also filtering to rg

# Making 4 types of phyloseq objects based on OTUs presence in PCR replicates:
# Raw data
# Raw data without soil sample's sequences -> see script 3_nosoil_phyloseq
# OTU dropped if only in single PCR replicate (i.e. OTU in at least 2/4 replicated) w/soil samples
# OTU dropped if only in two or fewer PCR replicates (i.e. OTU in at least 3/4 replicated) w/soil samples
# Only OTUs in all four PCR replicates w/soil samples

## Raw data including soil sample's sequences 
nopool.lulu.controlled_1
pool.lulu.controlled_1
pspool.lulu.controlled_1


## Raw data without soil sample's sequences -> see script 3_nosoil_phyloseq


#OTU dropped if only in single PCR replicate (i.e. OTU in at least 2/4 replicated)
rep.groups2 <- function(x){
  r2 <- apply(x, 2, function(c) replace(c, sum(c!=0)<2, 0))
  return(r2)
}

rg2.nopool.lulu.controlled <- lapply(nopool.lulu.controlled_1 , rep.groups2)
rg2.pool.lulu.controlled <- lapply(pool.lulu.controlled_1 , rep.groups2)
rg2.pspool.lulu.controlled <- lapply(pspool.lulu.controlled_1 , rep.groups2)

#OTU dropped if only in two or fewer PCR replicates (i.e. OTU in at least 3/4 replicated)
rep.groups3 <- function(x){
  r3 <- apply(x, 2, function(c) replace(c, sum(c!=0)<3, 0))
  return(r3)
}

rg3.nopool.lulu.controlled <- lapply(nopool.lulu.controlled_1 , rep.groups3)
rg3.pool.lulu.controlled <- lapply(pool.lulu.controlled_1 , rep.groups3)
rg3.pspool.lulu.controlled <- lapply(pspool.lulu.controlled_1 , rep.groups3)

#Only OTUs in all four PCR replicates 

rep.groups4 <- function(x){
  r4 <- apply(x, 2, function(c) replace(c, sum(c!=0)<4, 0))
  return(r4)
}


rg4.nopool.lulu.controlled <- lapply(nopool.lulu.controlled_1 , rep.groups4)
rg4.pool.lulu.controlled <- lapply(pool.lulu.controlled_1 , rep.groups4)
rg4.pspool.lulu.controlled <- lapply(pspool.lulu.controlled_1 , rep.groups4)

## now we can extract the sequence data and make a phylopseq object - taxonomy can be added later

### extracting sequence data
library(dada2)
nopool.lulu.controlled_1 <- lapply(nopool.lulu.controlled_1, as.matrix)
pool.lulu.controlled_1 <- lapply(pool.lulu.controlled_1, as.matrix)
pspool.lulu.controlled_1 <- lapply(pspool.lulu.controlled_1, as.matrix)

uniquesToFasta(as.matrix(nopool.lulu.controlled_1[[1]]), fout="/data/lastexpansion/danieang/data/trimmed/mergedPlates2/nopool.fasta", ids=paste0("OTU", seq(length(getSequences(nopool.lulu.controlled_1[[1]])))))
uniquesToFasta(as.matrix(pool.lulu.controlled_1[[1]]), fout="/data/lastexpansion/danieang/data/trimmed/mergedPlates2/pool.fasta", ids=paste0("OTU", seq(length(getSequences(pool.lulu.controlled_1[[1]])))))
uniquesToFasta(as.matrix(pspool.lulu.controlled_1[[1]]), fout="/data/lastexpansion/danieang/data/trimmed/mergedPlates2/pspool.fasta", ids=paste0("OTU", seq(length(getSequences(pspool.lulu.controlled_1[[1]])))))

sequence_lengths3 <- nchar(getSequences("/data/lastexpansion/danieang/data/trimmed/mergedPlates2/nopool.fasta"))
summary(sequence_lengths3)


library(phyloseq)
library(seqinr)
#reading back in sequence files
nopoolseqs <- read.fasta("nopool.fasta")
row.names(nopoolseqs) <- nopoolseqs$id
poolseqs  <- read.fasta("pool.fasta")
row.names(poolseqs) <- poolseqs$seq.name
pspoolseqs  <- read.fasta("pspool.fasta")
row.names(pspoolseqs) <- pspoolseqs$seq.name

## Function to make phylosequ object from OTU, tax data and sample data

to.one.matrix <- function(x){
  lah <- do.call(rbind.data.frame, x)
  rownames(lah) <- names(x)
  colnames(lah) <- names(x[[1]])
  lah <- as.matrix(lah)
  return(lah)
}

row.names(exdata) <- exdata$sample

make.phylo <- function (x, z, k){ # x = OTU data to this point, z = sample data, k = sequence data
  ## Summing all the replicates to get a single row for each sample
  single <- lapply(x, function(w) colSums(w) )
  ### getting a single matrix from list of samples (with single row)
  test <- to.one.matrix(single)
  ## Giving the columns the OTU name instead of the sequence 
  colnames(test) <-  names(k)
  ### Making phyloseq initial object
  wanted <- phyloseq(otu_table(test, taxa_are_rows = FALSE), sample_data(z))
  ## getting DNA data
  dna <- Biostrings::DNAStringSet(colnames(x[[1]]))
  ## naming sequences as OTUs
  names(dna) <- names(k)
  ##Finishinf phyloseq object
  wanted <- merge_phyloseq(wanted, dna)
  return(wanted)
}



## making phyoseq data from raw data w/ soil samples
nopool.ps <- make.phylo(nopool.lulu.controlled_1 , exdata, nopoolseqs)
pool.ps <- make.phylo(pool.lulu.controlled_1 , exdata, poolseqs)
pspool.ps <- make.phylo(pspool.lulu.controlled_1 , exdata, pspoolseqs)


## making phyloseq data from rg2 (OTU in at least 2 replicates data) w/soil
rg2.nopoolps <- make.phylo(rg2.nopool.lulu.controlled , exdata, nopoolseqs)
rg2.poolps <- make.phylo(rg2.pool.lulu.controlled , exdata, poolseqs)
rg2.pspoolps <- make.phylo(rg2.pspool.lulu.controlled , exdata, pspoolseqs)

## making phyloseq data from rg3 (OTU in at least 3 replicates data) w/soil
rg3.nopoolps <- make.phylo(rg3.nopool.lulu.controlled , exdata, nopoolseqs)
rg3.poolps <- make.phylo(rg3.pool.lulu.controlled , exdata, poolseqs)
rg3.pspoolps <- make.phylo(rg3.pspool.lulu.controlled , exdata, pspoolseqs)

## making phyloseq data from rg4 (OTU in at least 4 replicates data) w/soil
rg4.nopoolps <- make.phylo(rg4.nopool.lulu.controlled , exdata, nopoolseqs)
rg4.poolps <- make.phylo(rg4.pool.lulu.controlled , exdata, poolseqs)
rg4.pspoolps <- make.phylo(rg4.pspool.lulu.controlled , exdata, pspoolseqs)




saveRDS(nopool.ps, "nopool_ps.rds")
saveRDS(pool.ps, "pool_ps.rds")
saveRDS(pspool.ps, "pspool_ps.rds")

saveRDS(rg2.nopoolps, "rg2.nopoolps.rds")
saveRDS(rg2.poolps, "rg2.poolps.rds")
saveRDS(rg2.pspoolps, "rg2.pspoolps.rds")

saveRDS(rg3.nopoolps, "rg3.nopoolps.rds")
saveRDS(rg3.poolps, "rg3.poolps.rds")
saveRDS(rg3.pspoolps, "rg3.pspoolps.rds")

saveRDS(rg4.nopoolps, "rg4.nopoolps.rds")
saveRDS(rg4.poolps, "rg4.poolps.rds")
saveRDS(rg4.pspoolps, "rg4.pspoolps.rds")


nopoolps_wSoil <- "/data/lastexpansion/danieang/data/trimmed/mergedPlates/nopool_phyloseq_soil.rds"
poolps_wSoil <- "/data/lastexpansion/danieang/data/trimmed/mergedPlates/pool_phyloseq_soil.rds" 
pspoolps_wSoil <- "/data/lastexpansion/danieang/data/trimmed/mergedPlates/pspool_phyloseq_soil.rds"

# Sumar el número total de reads en phyloseq object
total_reads <- sum(phyloseq::otu_table(nopoolps_wSoil))
cat("Número total de reads:", total_reads, "\n")

# Contar el número de OTUs en phyloseq object
num_otus <- phyloseq::ntaxa(nopoolps_wSoil)
cat("Número de OTUs:", num_otus, "\n")


str(exdata)
### All data is in phyloseq objects now

plot_richness(nopoolps, x="biome", color="elevation_adj")

plot_richness(poolps, x="elevation_adj", color="site")

library(microViz)
library(ggplot2)

## look into microviz for ways to examine your data..

save.image("merged_ITS2.RData")

################

#Now creating phyloseq objects without soil samples -> original code from example script


opool.lulu.ntc.blankC2 <- lapply(nopool.lulu.ntc.blankC2,function(x) as.data.frame(x))
pool.lulu.ntc.blankC2 <- lapply(pool.lulu.ntc.blankC2,function(x) as.data.frame(x))
pspool.lulu.ntc.blankC2 <- lapply(pspool.lulu.ntc.blankC2,function(x) as.data.frame(x))

nopool.lulu.ntc.blank.fieldb <- dplyr::bind_rows(nopool.lulu.ntc.blankC2, .id = "column_label")
pool.lulu.ntc.blank.fieldb <- dplyr::bind_rows(pool.lulu.ntc.blankC2, .id = "column_label")
pspool.lulu.ntc.blank.fieldb <- dplyr::bind_rows(pspool.lulu.ntc.blankC2, .id = "column_label")


## function to group samples into lists via field blanks

exblank.to.fieldblankcontrol <-  function (x){
  z <- x
  <- dplyr::bind_rows(nopool.lulu.index, .id = "column_label")
  row.names() = $full
  z = merge(nopool.lulu.ntc, , by =  'row.names', all.x=TRUE)
  z = merge(z, exdata, by.x="sample", by.y="sample", all.x=TRUE)
  rownames(z) <- z$Row.names 
  z = split(z, z$Fieldcontrol)
  dropnames <- colnames(z[[2]][, c(which(nchar(colnames(z[[2]]))< 30))])
  z <- lapply(z, function(x) x[!(names(x) %in% dropnames)])
  z = lapply(z, as.matrix)
  return(z)
}

nopool.lulu.ntc.blank.fieldblist <- exblank.to.fieldblankcontrol(nopool.lulu.ntc.blank.fieldb)
pool.lulu.ntc.blank.fieldblist <- exblank.to.fieldblankcontrol(pool.lulu.ntc.blank.fieldb)
pspool.lulu.ntc.blank.fieldblist <- exblank.to.fieldblankcontrol(pspool.lulu.ntc.blank.fieldb)


## getting rid non-samples experimental controls with no blank samples
nopool.lulu.ntc.blank.fieldblist <- nopool.lulu.ntc.blank.fieldblist[-1]
pool.lulu.ntc.blank.fieldblist <- pool.lulu.ntc.blank.fieldblist[-1]
pspool.lulu.ntc.blank.fieldblist <- pspool.lulu.ntc.blank.fieldblist[-1]

unique(exdata$Fieldcontrol) # copy in blank extract names
fb.blank.change <- function(x){
  mind <- apply(x[grep("S_S1_1|S_S1_2|S_S1_3|S_S1_4|S_S1_5|S_S1_6|S_S1_7|S_S2_1|S_S2_2|S_S2_3|S_S2_4|S_S2_5", rownames(x)), ], 2, function(y) max(y, na.rm = TRUE))
  x1 <- sweep(x, 2, mind)
  x1 <- pmax(x1,0)
  return(x1)
}

nopool.lulu.ntc.blank.fieldblist1 <- lapply(nopool.lulu.ntc.blank.fieldblist, fb.blank.change)
pool.lulu.ntc.blank.fieldblist1 <- lapply(pool.lulu.ntc.blank.fieldblist, fb.blank.change)
pspool.lulu.ntc.blank.fieldblist1 <- lapply(pspool.lulu.ntc.blank.fieldblist, fb.blank.change)

nopool.lulu.ntc.blank.fieldblist1 <- lapply(nopool.lulu.ntc.blank.fieldblist1,function(x) replace(x, !is.finite(x), 0))
pool.lulu.ntc.blank.fieldblist1 <- lapply(pool.lulu.ntc.blank.fieldblist1, function(x) replace(x, !is.finite(x), 0))
pspool.lulu.ntc.blank.fieldblist1 <- lapply(pspool.lulu.ntc.blank.fieldblist1, function(x) replace(x, !is.finite(x), 0))

## Merging data back to just biological samples
##### The same can occur for field blanks - merging dataset again
nopool.lulu.ntc.blank.fieldblist1 <- lapply(nopool.lulu.ntc.blank.fieldblist1,function(x) as.data.frame(x))
pool.lulu.ntc.blank.fieldblist1 <- lapply(pool.lulu.ntc.blank.fieldblist1,function(x) as.data.frame(x))
pspool.lulu.ntc.blank.fieldblist1 <- lapply(pspool.lulu.ntc.blank.fieldblist1,function(x) as.data.frame(x))


nopool.lulu.ntc.blank.fielddone<- dplyr::bind_rows(nopool.lulu.ntc.blank.fieldblist1, .id = "column_label")

pool.lulu.ntc.blank.fielddone<- dplyr::bind_rows(pool.lulu.ntc.blank.fieldblist1, .id = "column_label")

pspool.lulu.ntc.blank.fielddone<- dplyr::bind_rows(pspool.lulu.ntc.blank.fieldblist1, .id = "column_label")

#removing column id labels
nopool.lulu.ntc.blank.fielddone<- nopool.lulu.ntc.blank.fielddone[,-1]
pool.lulu.ntc.blank.fielddone<- pool.lulu.ntc.blank.fielddone[,-1]
pspool.lulu.ntc.blank.fielddone<-  pspool.lulu.ntc.blank.fielddone[,-1]
## need to remove non-biological samples from dataframes and split into lists of individual samples for replicate control and combination etc

unique(rownames(nopool.lulu.ntc.blank.fielddone))

## only field blanks (with zero sequences in) remain so removing these 

### All samples controlled (by sequence count) for blank extract and field blanks
## function to remove control samples (blanks, ntc, positive controls and tagcatches) and making lists of dataframes by samples for later


#Function to remove field controls (soil samples) from phyloseq object

controlledblanks.to.samplelist <-  function (x) {
  minusNTCBLANK.sample <- x
  
  # List of samples to remove
  samples_to_remove <- c("S_S1_1_P1", "S_S1_3_P1", "S_S1_4_P1", "S_S1_5_P1", 
                         "S_S1_6_P1", "S_S1_7_P1", "S_S2_2_P1", "S_S2_3_P1", 
                         "S_S2_4_P1", "S_S2_5_P1", "S_S1_2_P2", "S_S2_1_P2")
  # Remove the samples listed in 'samples_to_remove'
  minusNTCBLANK.sample <- minusNTCBLANK.sample[!rownames(minusNTCBLANK.sample) %in% samples_to_remove,]
  
  minusNTCBLANK.sample <-  merge(minusNTCBLANK.sample,  ,by =  'row.names', all.x=TRUE)
  rownames(minusNTCBLANK.sample) <- minusNTCBLANK.sample$Row.names
  minusNTCBLANK.sample <- split(minusNTCBLANK.sample, minusNTCBLANK.sample$sample)
  dropnames <- colnames(minusNTCBLANK.sample[[2]][, c(which(nchar(colnames(minusNTCBLANK.sample[[2]]))< 30))])
  minusNTCBLANK.sample <- lapply(minusNTCBLANK.sample, function(x) x[!(names(x) %in% dropnames)])
  return(minusNTCBLANK.sample)
}


nopool.lulu.controlled_1 <- controlledblanks.to.samplelist(nopool.lulu.ntc.blank.fielddone)
pool.lulu.controlled_1 <- controlledblanks.to.samplelist(pool.lulu.ntc.blank.fielddone)
pspool.lulu.controlled_1 <-  controlledblanks.to.samplelist(pspool.lulu.ntc.blank.fielddone)


## making phyoseq data from raw data without soil samples
nopoolps <- make.phylo(nopool.lulu.controlled_1 , exdata, nopoolseqs)
poolps <- make.phylo(pool.lulu.controlled_1 , exdata, poolseqs)
pspoolps <- make.phylo(pspool.lulu.controlled_1 , exdata, pspoolseqs)

