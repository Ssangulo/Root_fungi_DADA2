#Ecological analysis edited pipeline for paper


library(phyloseq)
library(microViz)
library(DECIPHER)
library(phangorn)
library(iNEXT.3D)
library(rlist)
library(vegan)
library(fantaxtic)
library(tidytree) #Need version 0.4.2 for functioning properly
library(ggplot2)
library(ggordiplots)
library(VennDiagram)
library(venn)
library(dplyr)
library(dada2)
library(ape)
library(picante)
library(tidyr)

load("eco_analysis.RData")

saveRDS(ps_fungi, "/data/lastexpansion/danieang/objects/phyloseq_main_rg2_nosoil.rds")
saveRDS(individual_ps, "/data/lastexpansion/danieang/objects/ps_individual.rds")
saveRDS(balanced_ps, "/data/lastexpansion/danieang/objects/ps_balanced_permanova.rds")
saveRDS(dists, "/data/lastexpansion/danieang/objects/dist_ait.rds")



np2 <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg2.poolps.rds")
np3 <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg3.poolps.rds")
np4 <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg4.poolps.rds")

np1.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/poolps.dada2.nosoil.rds")
np2.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg2.poolps_tax_nosoil.rds")
np3.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg3.poolps_tax_nosoil.rds")
np4.N <- readRDS("/data/lastexpansion/danieang/data/trimmed/mergedPlates/rg4.poolps_tax_nosoil.rds")

otu_tab<- otu_table(np2)  
dim(otu_tab)

new_metadata <- read.csv("/data/lastexpansion/danieang/data/trimmed/mergedPlates/ITS_metadata_Soil.csv", row.names = 1)

sample_data(np1) <- sample_data(new_metadata)
sample_data(np2) <- sample_data(new_metadata)
sample_data(np3) <- sample_data(new_metadata)
sample_data(np4) <- sample_data(new_metadata)

sample_data(np1.N) <- sample_data(new_metadata)
sample_data(np2.N) <- sample_data(new_metadata)
sample_data(np3.N) <- sample_data(new_metadata)
sample_data(np4.N) <- sample_data(new_metadata)


library(phyloseq)

alldat <- list(np1, np2, np3, np4) #Full dataset
alldat.N <- list(np1.N, np2.N, np3.N, np4.N) #root samples only, soil reads removed
alldat.root <- list(np1, np2, np3, np4) #root samples only, no remmoving soil reads

names(alldat) <- c("nofilt", "rg2", "rg3", "rg4")
names(alldat.N) <- c("nofilt", "rg2", "rg3", "rg4")
names(alldat.root) <- c("nofilt", "rg2", "rg3", "rg4")

#Removing 12 soil samples from list alldat.root
alldat.root <- lapply(alldat.root, function(ps_obj) {
  subset_samples(ps_obj, Individual != "S")
})


library(microViz)

alldat <- lapply(alldat, function(x) phyloseq_validate(x, remove_undetected = TRUE))
alldat.N <- lapply(alldat.N, function(x) phyloseq_validate(x, remove_undetected = TRUE))
alldat.root <- lapply(alldat.root, function(x) phyloseq_validate(x, remove_undetected = TRUE))


alldat
alldat.N



## Basic look at data
seqs <- rowSums(otu_table(np2.N))
min(colSums(otu_table(np2.N)))
otus <- apply(otu_table(np2.N), MARGIN=1, FUN=function(x) {length( x[x > 0] )} )
plot(seqs, otus)

### Some rarefaction to look at library depth adequacy
library(vegan)
ttab <- t(otu_table(np1))
class(ttab) <- "matrix" 
raremin <- min(rowSums(ttab))
rarecurve(ttab, step = 100, sample = raremin, col = "blue", label = FALSE)

### rareyfing data - but checking the minimum sequence count per smaple first sentence # samples are rows
min(rowSums(otu_table(alldat[[1]])))
min(rowSums(otu_table(alldat[[2]])))
min(rowSums(otu_table(alldat[[3]])))
min(rowSums(otu_table(alldat[[4]])))
## need to get rid of samples in the rg4 object with zero reads - removing 8 samples
k <- prune_samples(sample_sums(alldat[[4]]) > 0, alldat[[4]])
alldat[[4]] <- k

#Same process with Nosoil datasets
min(rowSums(otu_table(alldat.N[[1]])))
min(rowSums(otu_table(alldat.N[[2]])))
min(rowSums(otu_table(alldat.N[[3]])))
min(rowSums(otu_table(alldat.N[[4]])))
#Removing samples with zero reads in all 4 .N objects -> Removing 12 empty soil samples from each + unknown from np4.N
k1 <- prune_samples(sample_sums(alldat.N[[1]]) > 0, alldat.N[[1]])
alldat.N[[1]] <- k1
k2 <- prune_samples(sample_sums(alldat.N[[2]]) > 0, alldat.N[[2]])
alldat.N[[2]] <- k2
k3 <- prune_samples(sample_sums(alldat.N[[3]]) > 0, alldat.N[[3]])
alldat.N[[3]] <- k3
k4 <- prune_samples(sample_sums(alldat.N[[4]]) > 0, alldat.N[[4]])
alldat.N[[4]] <- k4 #Removed 10 more samples in this object



## checking again
min(rowSums(otu_table(alldat.root[[4]]))) #lame
hist(rowSums(otu_table(alldat[[4]]))) ## need to filter out samples with less than 100,000 sequences
k <- prune_samples(sample_sums(alldat[[4]]) > 100000, alldat[[4]])
alldat[[4]] <- k #Removed 11 samples
k3 <- prune_samples(sample_sums(alldat[[3]]) > 100000, alldat[[3]])
alldat[[3]] <- k3 #Removed 1 sample

k <- prune_samples(sample_sums(alldat.root[[4]]) > 100000, alldat.root[[4]])
alldat.root[[4]] <- k #Removed 7 samples

min(rowSums(otu_table(alldat.N[[4]]))) #11,516 for nosoil object -> filtering out samples with less than 100,000 seq
k4 <- prune_samples(sample_sums(alldat.N[[4]]) > 100000, alldat.N[[4]])
alldat.N[[4]] <- k4 #Removed 7 samples


rarfun  <- function(x) {
  rfy <- min(rowSums(otu_table(x)))
  sar.rats.rarefy <- rarefy_even_depth(x, sample.size=rfy, replace=FALSE, rngseed = 1)
  return(sar.rats.rarefy)
}

rfy <- min(rowSums(otu_table(alldat.root[[4]]))) 
alldat.root.rfy <- lapply(alldat.root, rarfun)

#Same process for nosoil objects
rarfun  <- function(x) {
  rfy <- min(rowSums(otu_table(x)))
  sar.rats.rarefy <- rarefy_even_depth(x, sample.size=rfy, replace=FALSE, rngseed = 1)
  return(sar.rats.rarefy)
}

rfy <- min(rowSums(otu_table(alldat.N[[4]])))
alldat.N.rfy <- lapply(alldat.N, rarfun)


## having a look at sample data summary
library(ggordiplots)
k <- as.data.frame(sample_data(alldat.root[[2]]))
head(k)
table(k$elevation_adj, k$site_elevation)
table(k$site,k$elevation_adj)

## Fixing tax tables by filling out N fields
alldat <- lapply(alldat, function(x) tax_fix(x,
                                             min_length = 3,
                                             unknowns = c(""),
                                             sep = " ", anon_unique = TRUE,
                                             suffix_rank = "classified"))


alldat.N <- lapply(alldat.N, function(x) tax_fix(x,
                                                 min_length = 3,
                                                 unknowns = c(""),
                                                 sep = " ", anon_unique = TRUE,
                                                 suffix_rank = "classified"))
alldat.root <- lapply(alldat.root, function(x) tax_fix(x,
                                                       min_length = 3,
                                                       unknowns = c(""),
                                                       sep = " ", anon_unique = TRUE,
                                                       suffix_rank = "classified"))



library(fantaxtic)

## labelling unique OTUslapply
alldat <- lapply(alldat, function(x) label_duplicate_taxa(x, "Species", duplicate_label = "<tax> <id>"))
head(tax_table(alldat[[2]]), n = 20)

alldat.N <- lapply(alldat.N, function(x) label_duplicate_taxa(x, "Species", duplicate_label = "<tax> <id>"))
head(tax_table(alldat.N[[2]]), n = 20)

alldat.root <- lapply(alldat.root, function(x) label_duplicate_taxa(x, "Species", duplicate_label = "<tax> <id>"))
head(tax_table(alldat.root[[2]]), n = 20)


save.image(file = "eco_analysis.RData")
load("eco_analysis.RData")

## having a look at sample data summary
k <- as.data.frame(sample_data(ps))
head(k)
table(k$site, k$habitat, k$elevation_adj)
table(k$site,k$elevation)


NV_BEL_DOM <- subset_samples(alldat.N[[2]], site %in% c("NV","BEL","DOM"))
NV_BEL_DOM <- subset_samples(NV_BEL_DOM, !(site_elevation == "NV_4"))
NV_BEL_DOM <- subset_samples(NV_BEL_DOM, !(site_elevation == "BEL_3"))
NV_BEL_DOM <- prune_taxa(taxa_sums(NV_BEL_DOM) > 0, NV_BEL_DOM)

balanced_ps <- subset_samples(individual_ps, site %in% c("DOM", "NV"))
balanced_ps <- subset_samples(balanced_ps, !(site_elevation == "NV_4"))
balanced_ps <- prune_taxa(taxa_sums(balanced_ps) > 0, balanced_ps)  # Prune taxa with zero abundance


ps <- alldat.N[[2]]

## PCA on Aitchison distances (ecluidean distances from robust clr transformed data)
rfyrg2 <- decostand(otu_table(ps), "rclr", MARGIN=1)
my.rda <- rda(rfyrg2)
gdata <- sample_data(ps)
p <- gg_ordiplot(my.rda, groups = gdata$habitat, pt.size = 3, spiders = TRUE, ellipse = FALSE)

p <- gg_ordiplot(my.rda, groups = gdata$habitat, pt.size = 3, spiders = TRUE, ellipse = FALSE)
p <- p$plot
ggsave("/data/lastexpansion/danieang/Plots2/PCA_rg2N_site.png", plot = p, device = "png", width = 10, height = 6, dpi = 600)

# temporarily force a headless graphics device so gg_ordiplot doesn't try X11
old_dev <- getOption("device")
options(device = function(...) pdf(NULL))
on.exit(options(device = old_dev), add = TRUE)



# Merging the two samples (replicates) from each individual (sum of OTU counts) for pseudoreplication-sensitive analyses: PERMANOVA, dbRDA, beta-regression and NRI/NTI
# Extract OTU table and sample data

ps <- alldat.N[[2]]

new_metadata <- read.csv("/data/lastexpansion/danieang/data/trimmed/mergedPlates/fix_metadata.csv",
                         row.names = 1)
sample_data(ps) <- sample_data(new_metadata)

# 1) OTU table as SAMPLES x TAXA (rows = samples, cols = OTUs)
otu_table_data <- otu_table(ps)
if (taxa_are_rows(ps)) otu_table_data <- t(otu_table_data)

# 2) Data frames
otu_table_df <- as.data.frame(otu_table_data, check.names = FALSE)
otu_table_df$SampleID <- rownames(otu_table_df)

sample_data_df <- data.frame(sample_data(ps), check.names = FALSE)
sample_data_df$SampleID <- rownames(sample_data_df)

# 3) Merge and remember which columns are OTUs
otu_cols <- setdiff(colnames(otu_table_df), "SampleID")

combined_df <- merge(
  otu_table_df,
  sample_data_df,
  by = "SampleID",
  all.x = TRUE
)

# be safe: OTU columns numeric
combined_df[otu_cols] <- lapply(combined_df[otu_cols], function(x) as.numeric(as.character(x)))

# 4) Sum OTUs by Unique_ID
summed_df <- combined_df |>
  dplyr::group_by(Unique_ID) |>
  dplyr::summarise(dplyr::across(dplyr::all_of(otu_cols), ~ sum(.x, na.rm = TRUE)),
                   .groups = "drop")

# 5) Keep ONE metadata row per Unique_ID, **excluding OTU columns**
first_sample_ids <- combined_df |>
  dplyr::group_by(Unique_ID) |>
  dplyr::summarise(dplyr::across(-dplyr::all_of(otu_cols), ~ dplyr::first(.x)),
                   .groups = "drop")

# 6) Join metadata + summed OTUs
final_df <- dplyr::left_join(first_sample_ids, summed_df, by = "Unique_ID")

# 7) Build matrices/metadata for phyloseq
otu_summed <- final_df |>
  dplyr::select(dplyr::all_of(otu_cols)) |>
  as.matrix()

# use Unique_ID as the collapsed sample name
rownames(otu_summed) <- final_df$Unique_ID

sample_metadata <- final_df |>
  dplyr::select(Unique_ID, site, site_elevation, habitat, treeline, Individual,
                elevation, elevation_adj) |>
  as.data.frame()

rownames(sample_metadata) <- sample_metadata$Unique_ID
sample_metadata$Unique_ID <- NULL

# 8) Make phyloseq (reuse taxonomy from ps if present)
otu_ps <- otu_table(otu_summed, taxa_are_rows = FALSE)
sample_ps <- sample_data(sample_metadata)

if (!is.null(tax_table(ps, errorIfNULL = FALSE))) {
  individual_ps <- phyloseq(otu_ps, sample_ps, tax_table(ps))
} else {
  individual_ps <- phyloseq(otu_ps, sample_ps)
}

# drop zero-sum taxa (optional, same as you did elsewhere)
individual_ps <- prune_taxa(taxa_sums(individual_ps) > 0, individual_ps)


individual_ps


#Making PERMANOVA and beta dispersion tests

balanced_ps <- subset_samples(individual_ps, site %in% c("DOM", "NV"))
balanced_ps <- subset_samples(balanced_ps, !(site_elevation == "NV_4"))
balanced_ps <- prune_taxa(taxa_sums(balanced_ps) > 0, balanced_ps)  # Prune taxa with zero abundance


dists <- vegdist(otu_table(balanced_ps), binary=FALSE, method="robust.aitchison") 
sampledf <- data.frame(sample_data(balanced_ps))
#sampledf$elevation_adj <- factor(sampledf$elevation_adj) # Convert elevation_adj to a factor

#adonis2(dists ~ elevation_adj, data = sampledf)
adonis2(dists ~ site * habitat, by = "terms", data = sampledf)


beta <- betadisper(dists, sampledf$habitat)
beta1 <- betadisper(dists, sampledf$site)

permutest(beta)
permutest(beta1)

#Running dbRDA with robust aitchison

ps <- individual_ps

d_ait <- vegdist(otu_table(ps), binary=FALSE, method="robust.aitchison")

sam <- data.frame(sample_data(ps))

sam$habitat <- factor(sam$habitat)  # levels inferred from data

## 1) dbRDA: habitat while conditioning on site
mod_ait <- capscale(d_ait ~ habitat + Condition(site), data = sam)

## 2) Permutation tests (for your Results text)
cat("\n== dbRDA overall ==\n")
print(anova.cca(mod_ait))                  # overall
cat("\n== dbRDA by term ==\n")
print(anova.cca(mod_ait, by = "terms"))    # habitat effect
cat("\n== dbRDA by axis ==\n")
print(anova.cca(mod_ait, by = "axis"))     # axes significance

## 3) % variance for the first two constrained axes (for axis labels)
eig_con <- mod_ait$CCA$eig
cap1_pct <- round(100 * eig_con[1] / sum(eig_con), 1)
cap2_pct <- round(100 * eig_con[2] / sum(eig_con), 1)

xlab_txt <- paste0("dbRDA1 (", cap1_pct, "%)")
ylab_txt <- paste0("dbRDA2 (", cap2_pct, "%)")

png("/data/lastexpansion/danieang/Plots2/dbRDA_collapsed.png",
    width = 7.5, height = 6.5, units = "in", res = 600)

par(mfrow = c(1,1), mar = c(4,4,1,1), xpd = NA, cex = 1)

# Colors and shapes
cols <- c("forest" = "#1f77b4", "subparamo" = "#2ca02c", "paramo" = "#d62728")
pchv <- c("forest" = 16, "subparamo" = 17, "paramo" = 15)

# Empty plot, suppress auto axes and labels
plot(mod_ait, display = c("sites","cn"), type = "n",
     xaxt="n", yaxt="n", xlab="", ylab="")

# Draw points
with(sam, points(scores(mod_ait, display="sites"),
                 col = cols[habitat], pch = pchv[habitat], cex = 0.6))

# Bigger ellipses (1 SD, 95% CI)
with(sam, ordiellipse(mod_ait, habitat, kind="sd", level=0.95,
                      draw="polygon",
                      col = adjustcolor(unname(cols[levels(habitat)]), alpha.f=0.2),
                      border = unname(cols[levels(habitat)]), lwd=1.2))

# Centroids
cen <- with(sam, ordiellipse(mod_ait, habitat, kind="sd", level=0.95, plot=FALSE))
cen_xy <- do.call(rbind, lapply(cen, `[[`, "centroid"))
points(cen_xy, pch = 4, cex = 1.2, lwd = 1.4, col = unname(cols[rownames(cen_xy)]))

# Legend
legend("topright", inset=0.01, bty="n",
       legend = c("Forest","Subpáramo","Páramo"),
       col = cols, pch = c(16,17,15), pt.cex=0.9, cex=0.9)

# Custom axis labels only
mtext("dbRDA1", side=1, line=2.5)
mtext("dbRDA2", side=2, line=2.5)

dev.off()


## Distance to centroid test to test paralell elevation effect across sites

ps <- individual_ps

## --- OTU -> matrix (samples in rows) ---
X <- otu_table(ps)
if (taxa_are_rows(ps)) X <- t(X)
X <- as.matrix(X)

## --- robust CLR ---
rfyrg2 <- decostand(X, "rclr", MARGIN = 1)

## --- metadata ---
meta <- data.frame(sample_data(ps), stringsAsFactors = FALSE, check.names = FALSE)
stopifnot(identical(rownames(rfyrg2), rownames(meta)))

meta$site <- as.character(meta$site)

## --- site centroids ---
centroids <- rowsum(rfyrg2, group = meta$site) / as.vector(table(meta$site))

## --- distances ---
euclid <- function(x, y) sqrt(sum((x - y)^2))

dist_centroid <- vapply(
  seq_len(nrow(rfyrg2)),
  function(k) {
    s <- meta$site[k]
    euclid(rfyrg2[k, ], centroids[s, ])
  },
  numeric(1)
)

## --- attach distances to meta + ps (this is the important part) ---
meta$dist_centroid <- dist_centroid
sample_data(ps)$dist_centroid <- dist_centroid   # write into phyloseq object too

## --- model dataframe (fresh) ---
df <- meta
df$site <- factor(df$site)
df$elevation <- as.numeric(df$elevation)
df$dist_centroid <- as.numeric(df$dist_centroid)

## --- parallel slopes test ---
mod <- lm(dist_centroid ~ elevation * site, data = df)
anova(mod)
summary(mod)

##### Running same model but with habitat instead of continuous elevation

df$habitat <- factor(df$habitat, levels = c("forest", "subparamo", "paramo"))

mod_hab <- lm(dist_centroid ~ habitat * site, data = df)
anova(mod_hab)
summary(mod_hab)



#PCoA on bray-curtis dissimilarities

ps <- alldat.N[[2]]

# 1) Data -> Bray-Curtis -> PCoA
mat <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) mat <- t(mat)
mat_rel <- vegan::decostand(mat, method = "total", MARGIN = 1)

bc  <- vegan::vegdist(mat_rel, method = "bray")
ord <- vegan::capscale(bc ~ 1)

# % variance (clip negatives for non-Euclidean metrics)
eig  <- pmax(ord$CA$eig, 0)
ax1p <- round(100 * eig[1] / sum(eig), 1)
ax2p <- round(100 * eig[2] / sum(eig), 1)

# 2) Site scores + metadata
sc <- as.data.frame(vegan::scores(ord, display = "sites", choices = 1:2, scaling = 1))
colnames(sc)[1:2] <- c("Axis1", "Axis2")
sc$sample <- rownames(sc)

meta <- as.data.frame(sample_data(ps))
meta$sample <- rownames(meta)
sc$habitat <- meta$habitat[match(sc$sample, meta$sample)]
sc$site    <- meta$site[match(sc$sample, meta$sample)]
sc$habitat <- droplevels(factor(sc$habitat))
sc$site    <- droplevels(factor(sc$site))

# 3) Centroids per habitat (for spider anchors)
cent <- aggregate(cbind(Axis1, Axis2) ~ habitat, data = sc, FUN = mean)
names(cent) <- c("habitat","cX","cY")
sc <- merge(sc, cent, by = "habitat", all.x = TRUE)

# 4) Plot with spiders (segments to centroid), color=habitat, shape=site
gp <- ggplot(sc, aes(Axis1, Axis2, colour = habitat, shape = site)) +
  # spider legs
  geom_segment(aes(xend = cX, yend = cY, group = interaction(habitat, sample)),
               alpha = 0.5, linewidth = 0.3, show.legend = FALSE) +
  # points
  geom_point(size = 3) +
  # centroid marks
  geom_point(data = cent, aes(x = cX, y = cY, colour = habitat),
             inherit.aes = FALSE, size = 3, shape = 4, stroke = 1) +
  coord_equal() +
  xlab(paste0("PCoA1 (", ax1p, "%)")) +
  ylab(paste0("PCoA2 (", ax2p, "%)")) +
  guides(colour = guide_legend(title = "Habitat", order = 1),
         shape  = guide_legend(title = "Site",    order = 2)) +
  theme_classic(base_size = 12)

ggsave("/data/lastexpansion/danieang/Plots2/PCoA_N2_noMA.png",
       plot = gp, width = 12, height = 8, dpi = 800)


#Phylogenetic diversity tree etc

##############

# Create phylogenetic data with soils sequences from O_Helotiales -> screen helotiales

helotiales <- alldat[[2]]  %>% tax_select(tax_list = "o__Helotiales")

align <- AlignSeqs(DNAStringSet(refseq(helotiales)), anchor=NA)

phang_align <- phyDat(as(align, "matrix"), type="DNA")
dm <- dist.ml(phang_align)
treeNJ <- NJ(dm)
fit <- pml(treeNJ, data=phang_align)
fitGTR <- update(fit, k=4, inv=0.2)
fit <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE, optNni=FALSE, optBf=TRUE, optQ=TRUE, optEdge=TRUE, optRooted=FALSE, rearrangement = "stochastic", control = pml.control(trace = 0))

tree_data_helotiales <- merge_phyloseq(helotiales, fit$tree)

## tree_data_sebacinales ...

#PD tree with rg2 no soil dataset (soil reads removed) -> this one used for analysis

align <- AlignSeqs(DNAStringSet(refseq(alldat.N[[2]])), anchor=NA)

phang_align <- phyDat(as(align, "matrix"), type="DNA")
dm <- dist.ml(phang_align)
treeNJ <- NJ(dm)
fit <- pml(treeNJ, data=phang_align)
fitGTR <- update(fit, k=4, inv=0.2)
fit <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE, optNni=FALSE, optBf=TRUE, optQ=TRUE, optEdge=TRUE, optRooted=FALSE, rearrangement = "stochastic", control = pml.control(trace = 0))

tree_data_rg2.N <- merge_phyloseq(alldat.N[[2]], fit$tree)

load("tree_data_rg2.N.RData")
tree_rg2.N <- readRDS("tree_rg2N.rds")

#PD plots with iNEXT3D

tree_rg2.N #phyloseq obj with rg2 root no soil data
tree_alldat_rg2 #phyloseq obj with rg2 alldata

ps <- tree_rg2.N 
## Correct mislabelled habitat: "pasture" -> "forest"
sd <- as.data.frame(sample_data(ps))

## replace values
sd$habitat <- as.character(sd$habitat)
sd$habitat[sd$habitat == "pasture"] <- "forest"

## assign back to ps
sample_data(ps)$habitat <- factor(sd$habitat)

## sanity: check after correction
cat("\nAfter correction:\n")
print(table(sample_data(ps)$habitat, useNA = "ifany"))


group_var <- "habitat"

# quick sanity
print(table(sample_data(ps)[[group_var]], useNA="ifany"))

# 1) incidence matrices: species (rows) x sampling-units (cols) per habitat
X <- as(otu_table(ps), "matrix"); if (taxa_are_rows(ps)) X <- t(X)
sd <- as.data.frame(sample_data(ps))
inc_by_hab <- lapply(split(seq_len(nrow(X)), sd[[group_var]]), function(i){
  M <- t(X[i,,drop=FALSE]); M[] <- as.integer(M>0); M[rowSums(M)>0,,drop=FALSE]
})
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]

# 2) tree prep: prune to observed taxa, drop duplicate labels, root if needed
tr <- phy_tree(ps)
keep <- intersect(tr$tip.label, unique(unlist(lapply(inc_by_hab, rownames))))
stopifnot(length(keep) >= 2)
tr2 <- keep.tip(tr, keep)
if (any(duplicated(tr2$tip.label))) tr2 <- drop.tip(tr2, which(duplicated(tr2$tip.label)))
tr2$node.label <- NULL
if (!is.rooted(tr2)) tr2 <- midpoint(tr2)

# align matrices to final tips
tipset <- tr2$tip.label
inc_by_hab <- lapply(inc_by_hab, function(M) M[rownames(M) %in% tipset,,drop=FALSE])
inc_by_hab <- inc_by_hab[vapply(inc_by_hab, function(M) nrow(M)>0 && ncol(M)>0, TRUE)]

# 3) run PD (meanPD) with incidence_raw
out_PD <- iNEXT3D(
  data      = inc_by_hab,
  diversity = "PD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 200, 
  PDtree    = tr2,
  PDtype    = "meanPD"
)



#Running NRI/NTI
library(picante)

# 1) Grab the tree from the full object
tr_full <- phy_tree(ps)

# 2) Prune the tree to the taxa present in individual_ps
tx_indiv <- taxa_names(individual_ps)
# (If all taxa are identical you can skip pruning; this is safer.)
tr_pruned <- keep.tip(tr_full, intersect(tx_indiv, tr_full$tip.label))

# 3) (Optional) ensure the tree is rooted
if (!is.rooted(tr_pruned)) {
  tr_pruned <- midpoint(tr_pruned)
}

# 4) Assign the tree into individual_ps
phy_tree(individual_ps) <- tr_pruned

# 5) Quick sanity checks
individual_ps

ps <- individual_ps

stopifnot(exists("ps"))
if (!exists("tr2")) {
  tr2 <- phy_tree(ps)
  if (!is.rooted(tr2)) {
    library(phangorn)
    tr2 <- midpoint(tr2)
  }
}

## 1) Build a samples x taxa abundance matrix, aligned to the tree tips
comm <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) comm <- t(comm)

# Keep only taxa present in the tree AND in the table
keep_taxa <- intersect(colnames(comm), tr2$tip.label)
comm <- comm[, keep_taxa, drop = FALSE]
tr2  <- ape::keep.tip(tr2, keep_taxa)

# Optional: drop ultra-rare taxa to stabilize nulls (tweak threshold to taste)
keep_taxa2 <- colSums(comm) >= 200
comm <- comm[, keep_taxa2, drop = FALSE]
tr2  <- ape::keep.tip(tr2, colnames(comm))

## 2) Metadata
md <- as(sample_data(ps), "data.frame")
md <- md %>% mutate(habitat = factor(habitat))

## 3) Compute phylogenetic distance matrix among taxa (tips)
dist_phy <- cophenetic(tr2)

## 4) Run null-model tests
set.seed(1)

# Abundance-weighted MPD/MNTD (often more stable for roots/mycobiomes)
mpd_aw  <- ses.mpd (comm, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = TRUE)
mntd_aw <- ses.mntd(comm, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = TRUE)

# Presence–absence versions (sometimes stronger elevation signal, but noisier)
comm_pa <- 1 * (comm > 0)
mpd_pa  <- ses.mpd (comm_pa, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = FALSE)
mntd_pa <- ses.mntd(comm_pa, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = FALSE)

# 0) Make sure md is aligned to comm (you already did this, keeping it)
md <- as.data.frame(md)
md <- md[rownames(comm), , drop = FALSE]

# 1) Build per-sample table and FIX rownames before cbind
out <- data.frame(
  sample = rownames(comm),
  NRI_aw  = -mpd_aw$mpd.obs.z,
  NTI_aw  = -mntd_aw$mntd.obs.z,
  NRI_pa  = -mpd_pa$mpd.obs.z,
  NTI_pa  = -mntd_pa$mntd.obs.z,
  stringsAsFactors = FALSE
)
rownames(out) <- out$sample  # <<< critical fix

# now this aligns correctly
out <- cbind(out, md[rownames(out), c("habitat","site"), drop = FALSE])

# 2) drop any rows with NA z-scores (can happen if a sample has <2 taxa after filtering)
out <- out[complete.cases(out[, c("NRI_aw","NTI_aw","NRI_pa","NTI_pa")]), ]
out$habitat <- droplevels(factor(out$habitat))
out$site    <- droplevels(factor(out$site))

# quick sanity checks
print(table(out$habitat, useNA="ifany"))
print(table(out$site, useNA="ifany"))

# 3) Habitat-level summaries

sum_hab <- out %>%
  group_by(habitat) %>%
  summarize(
    n = n(),
    NRI_aw_med = median(NRI_aw, na.rm=TRUE),  NRI_aw_IQR = IQR(NRI_aw, na.rm=TRUE),
    NTI_aw_med = median(NTI_aw, na.rm=TRUE),  NTI_aw_IQR = IQR(NTI_aw, na.rm=TRUE),
    NRI_pa_med = median(NRI_pa, na.rm=TRUE),  NRI_pa_IQR = IQR(NRI_pa, na.rm=TRUE),
    NTI_pa_med = median(NTI_pa, na.rm=TRUE),  NTI_pa_IQR = IQR(NTI_pa, na.rm=TRUE),
    .groups = "drop"
  )
print(sum_hab)

## 4) Simple models (primary = abundance-weighted), + clean residual checks
m_NTI_aw <- lm(NTI_aw ~ habitat + site, data = out)
m_NRI_aw <- lm(NRI_aw ~ habitat + site, data = out)

anova(m_NTI_aw); anova(m_NRI_aw)

# Residual diagnostics


png(filename = "/data/lastexpansion/danieang/Plots2/NTI_aw_residuals.png",
    width = 1800, height = 1600, res = 200) 

par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))  
plot(m_NTI_aw)  
par(mfrow = c(1, 1))

dev.off()  

###running beta-NTI
# Ensure data alignment
stopifnot(all(rownames(comm) %in% rownames(md)))

# Define a function to compute βNTI
compute_betaNTI <- function(comm_mat, tree, abundance_weighted = TRUE, nperm = 999, seed = 1) {
  set.seed(seed)
  Dphy <- cophenetic(tree)
  beta_mntd_obs <- comdistnt(comm_mat, Dphy, abundance.weighted = abundance_weighted)
  
  # Nulls via tip shuffling
  null_fun <- function(i) {
    tr_null <- tipShuffle(tree)
    comdistnt(comm_mat, cophenetic(tr_null), abundance.weighted = abundance_weighted)
  }
  beta_mntd_null_list <- lapply(seq_len(nperm), null_fun)
  mu  <- Reduce(`+`, beta_mntd_null_list) / nperm
  mu2 <- Reduce(`+`, lapply(beta_mntd_null_list, function(m) m*m)) / nperm
  sdv <- sqrt(pmax(0, mu2 - mu*mu))
  
  betaNTI <- (beta_mntd_obs - mu) / sdv
  return(betaNTI)
}

# 1) Abundance-weighted βNTI (primary metric)
betaNTI_aw <- compute_betaNTI(comm, tr2, abundance_weighted = TRUE, nperm = 999, seed = 1)

# 2) Presence–absence version (optional)
comm_pa   <- 1 * (comm > 0)
betaNTI_pa <- compute_betaNTI(comm_pa, tr2, abundance_weighted = FALSE, nperm = 999, seed = 1)

# 3) Convert to tidy data frame
to_long <- function(mat, md) {
  nms <- rownames(mat)
  utx <- upper.tri(mat)
  df <- tibble(
    sample_i = nms[row(mat)[utx]],
    sample_j = nms[col(mat)[utx]],
    betaNTI   = mat[utx]
  ) %>%
    left_join(md %>% rownames_to_column("sample") %>%
                select(sample, habitat, site),
              by = c("sample_i" = "sample")) %>%
    left_join(md %>% rownames_to_column("sample") %>%
                select(sample, habitat, site),
              by = c("sample_j" = "sample"),
              suffix = c("_i", "_j")) %>%
    mutate(
      same_habitat = habitat_i == habitat_j,
      same_site    = site_i == site_j,
      hab_pair = paste(pmin(as.character(habitat_i), as.character(habitat_j)),
                       pmax(as.character(habitat_i), as.character(habitat_j)), sep = "-")
    )
  df
}

betaNTI_aw_long <- to_long(betaNTI_aw, md)

# 4) Summaries
sum_beta <- betaNTI_aw_long %>%
  mutate(group = ifelse(same_habitat, "within", "between")) %>%
  group_by(group) %>%
  summarize(
    n_pairs = n(),
    median  = median(betaNTI, na.rm = TRUE),
    IQR     = IQR(betaNTI, na.rm = TRUE),
    prop_gt2  = mean(betaNTI >  2, na.rm = TRUE),
    prop_lt2  = mean(betaNTI < -2, na.rm = TRUE),
    prop_abs_lt2 = mean(abs(betaNTI) < 2, na.rm = TRUE),
    .groups = "drop"
  )
print(sum_beta)



#now running UniFrac PERMANOVA on PD in same session

# Sync taxa between ps and tr2
ps_u <- prune_taxa(taxa_names(ps) %in% tr2$tip.label, ps)
# (Optional) if some tips exist in tree but not in OTU table, prune them from tree too:
tr2 <- keep.tip(tr2, taxa_names(ps_u))

# Ensure the tree is in ps_u
phy_tree(ps_u) <- tr2

# Sanity
stopifnot(!is.null(phy_tree(ps_u)))
stopifnot(is.rooted(phy_tree(ps_u)))

#computing unifrac weighted and unweighted
UFw  <- UniFrac(ps_u, weighted = TRUE,  normalized = TRUE, parallel = FALSE, fast = TRUE)
UFuw <- UniFrac(ps_u, weighted = FALSE, normalized = TRUE, parallel = FALSE, fast = TRUE)
md   <- as(sample_data(ps_u), "data.frame")

set.seed(1)
per_w  <- adonis2(as.dist(UFw)  ~ habitat + site, by = "terms", data = md, permutations = 9999)
per_uw <- adonis2(as.dist(UFuw) ~ habitat + site, by = "terms", data = md, permutations = 9999)

# Homogeneity of dispersion across habitats (cite or mention if unequal)
bd_w  <- betadisper(as.dist(UFw),  md$habitat);  bdw_a  <- anova(bd_w)
bd_uw <- betadisper(as.dist(UFuw), md$habitat);  bduw_a <- anova(bd_uw)

per_w; per_uw
bdw_a; bduw_a


#
##########

################

#Taxonomic diversity analysis with iNEXT3D

ps <- alldat.N[[2]]

##  Sanity
stopifnot(inherits(ps, "phyloseq"))
if (is.null(sample_data(ps))) stop("sample_data(ps) missing.")
if (is.null(otu_table(ps)))  stop("otu_table(ps) missing.")
sd <- as.data.frame(sample_data(ps))
if (!"habitat" %in% names(sd)) stop("'habitat' not in sample_data.")

##  Build incidence matrices per habitat (species x sampling-unit, 0/1)
taxa_rows <- taxa_are_rows(ps)
OTU <- as(otu_table(ps), "matrix")
if (!taxa_rows) OTU <- t(OTU)

inc_by_hab <- lapply(split(rownames(sd), sd$habitat), function(samps){
  M <- OTU[, colnames(OTU) %in% samps, drop = FALSE]
  M[M > 0] <- 1
  storage.mode(M) <- "numeric"
  M
})

out_TD_1 <- iNEXT.3D::iNEXT3D(
  data      = inc_by_hab,
  diversity = "TD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 200
)

##  Relabel habitats  in the iNEXT3D object for clean legend/order
labs_map  <- c(forest = "Forest", subparamo = "Subpáramo", paramo = "Páramo")
lvl_order <- c("Forest", "Subpáramo", "Páramo")

.relabel <- function(df){
  if (!("Assemblage" %in% names(df))) return(df)
  df$Assemblage <- labs_map[df$Assemblage]
  df$Assemblage <- factor(df$Assemblage, levels = lvl_order)
  df
}
out_TD$TDInfo    <- .relabel(as.data.frame(out_TD$TDInfo))
out_TD$TDAsyEst  <- .relabel(as.data.frame(out_TD$TDAsyEst))
if (!is.null(out_TD$TDiNextEst)) {
  for (nm in names(out_TD$TDiNextEst)) {
    out_TD$TDiNextEst[[nm]] <- .relabel(as.data.frame(out_TD$TDiNextEst[[nm]]))
  }
}

## 
p_TD <- ggiNEXT3D(out_TD, type = 1, facet.var = "Order.q") +
  labs(x = "Sampling units") +
  theme_minimal(base_size = 14) +
  theme(
    plot.title   = element_blank(),
    legend.title = element_blank()
  )

print(p_TD)

ggsave("/data/lastexpansion/danieang/Plots2/iNEXT_TD_by_habitat.png",
       p_TD, width = 10, height = 6, dpi = 800, bg = "white")

###############


#Microviz tax barplot

#For soil data
#ps_soil <- alldat[[2]] %>% 
#  ps_filter(grepl("S", Individual))

filter_taxa_by_rank <- function(physeq_obj, rank_prefix = "o__", exclude_term = "Incertae_sedis") {
  taxa_assigned <- grepl(rank_prefix, tax_table(physeq_obj)[, "Order"])
  exclude_incertae_sedis <- !grepl(exclude_term, tax_table(physeq_obj)[, "Order"])
  taxa_filtered <- taxa_assigned & exclude_incertae_sedis
  physeq_filtered <- prune_taxa(taxa_filtered, physeq_obj)
  return(physeq_filtered)
}

ps_filtered <- filter_taxa_by_rank(alldat.N[[2]])

# Clean taxonomic prefixes like o__, g__, etc.
tax_table(ps_filtered) <- apply(
  tax_table(ps_filtered), 2, function(x) gsub("^[a-z]__", "", x)
)

# Recode habitat labels
sample_data(ps_filtered)$habitat <- dplyr::recode(
  as.character(sample_data(ps_filtered)$habitat),
  "forest"    = "Forest",
  "subparamo" = "Subpáramo",
  "paramo"    = "Páramo",
  .default = NA_character_
)


# Order the factor levels
sample_data(ps_filtered)$habitat <- factor(
  sample_data(ps_filtered)$habitat,
  levels = c("Forest","Subpáramo","Páramo"),
  ordered = TRUE
)

ps_filtered <- ps_filtered %>% ps_arrange(site)

#  within each site, order samples by Bray/OLO seriation at Order level ---
site_levels <- sample_data(ps_filtered) %>% as.data.frame() %>% pull(site) %>% unique()

samp_order <- unlist(lapply(site_levels, function(s) {
  ps_filtered %>%
    ps_filter(site == s) %>%
    ps_seriate(rank = "Order") %>%   # same tax_level you plot
    sample_names()                   # returns samples in seriated order
}))

# Barplot faceted by habitat, clean legend labels
p <- ps_filtered %>%
  comp_barplot(
    tax_level = "Order", n_taxa = 10, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other orders"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )

# Save the plot
ggsave(
  "/data/lastexpansion/danieang/Plots2/Order_barplot_ordered_site_2.png",
  plot = p, device = "png", width = 12, height = 8, dpi = 800
)




#Plot for phylum
phy <- ps_filtered %>%
  comp_barplot(
    tax_level = "Phylum", n_taxa = 5, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other phyla"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )

# Save the plot
ggsave(
  "/data/lastexpansion/danieang/Plots2/phylum_barplot_ordered_site_2.png",
  plot = phy, device = "png", width = 12, height = 8, dpi = 800
)

#Plot for class
class <- ps_filtered %>%
  comp_barplot(
    tax_level = "Class", n_taxa = 10, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other classes"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )

# Save the plot
ggsave(
  "/data/lastexpansion/danieang/Plots2/class_barplot_ordered_site_2.png",
  plot = class, device = "png", width = 12, height = 8, dpi = 800
)

#Plot for genus
genus <- ps_filtered %>%
  comp_barplot(
    tax_level = "Genus", n_taxa = 20, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other genera"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )

# Save the plot
ggsave(
  "/data/lastexpansion/danieang/Plots2/genus_barplot_ordered_site_2.png",
  plot = genus, device = "png", width = 12, height = 8, dpi = 800
)



#making panel plot

library(patchwork)


# --- Universal small axis style (for left column plots) ---
axis_tweak <- theme(
  axis.text.x = element_text(size = 6),
  axis.text.y = element_text(size = 5),
  axis.title  = element_text(size = 8)
)

# --- Universal legend style (for all plots) ---
legend_tweak <- theme(
  legend.position = "right",
  legend.key.size = unit(0.5, "cm"),
  legend.text = element_text(size = 11),      # larger legend text
  legend.title = element_text(size = 11, face = "bold")
)

# --- Individual plots with titles and styling ---
phy_lab <- phy +
  ggtitle("A) Phylum") +
  axis_tweak + legend_tweak +
  guides(fill = guide_legend(ncol = 1)) +    # vertical legend
  theme(plot.title = element_text(face = "bold", size = 12, hjust = 0))


genus_lab <- genus +
  ggtitle("B) Genus") +
  axis_tweak + legend_tweak +
  guides(fill = guide_legend(ncol = 1)) +
  theme(plot.title = element_text(face = "bold", size = 12, hjust = 0))

p_lab <- p +
  ggtitle("C) Order") +
  legend_tweak +
  guides(fill = guide_legend(ncol = 1)) +
  theme(
    plot.title = element_text(face = "bold", size = 12, hjust = 0),
    axis.text.x = element_text(size = 7),
    axis.text.y = element_text(size = 6)
  )

# --- Patchwork layout ---
design <- "
AC
BC
"

panel <- phy_lab + genus_lab + p_lab +
  plot_layout(
    design = design,
    widths = c(1.3, 1.65),
    heights = c(1, 1),
    guides = "keep"
  )

# --- Export ---
ggsave(
  "/data/lastexpansion/danieang/Plots2/Panel_SOIL_PhylumGenus_Order_1.png",
  plot = panel,
  width = 15, height = 10, dpi = 800
)


### % of taxonom assigned reads and OTUs summary

ps <- ps_fungi

# OTU matrix: taxa x samples
otu_mat <- as(otu_table(ps), "matrix")
if (!taxa_are_rows(ps)) otu_mat <- t(otu_mat)

# taxonomy table
tax <- as.data.frame(tax_table(ps))
tax$OTU_ID <- rownames(tax)

# metadata
sam <- as.data.frame(sample_data(ps))
sam$SampleID <- rownames(sam)

# habitats (formatted)
sam$habitat <- factor(
  sam$habitat,
  levels = c("forest", "subparamo", "paramo"),
  labels = c("Forest", "Subpáramo", "Páramo")
)

tax <- tax %>%
  mutate(
    assigned_phylum =
      str_detect(Phylum, "^p__") &
      !str_detect(Phylum, regex("fungi kingdom", ignore_case = TRUE)),
    
    assigned_class =
      str_detect(Class, "^c__") &
      !str_detect(Class, regex("fungi kingdom", ignore_case = TRUE)),
    
    assigned_order =
      str_detect(Order, "^o__") &
      !str_detect(Order, regex("incertae", ignore_case = TRUE)),
    
    assigned_genus =
      str_detect(Genus, "^g__") &
      !str_detect(Genus, regex("incertae", ignore_case = TRUE))
  )

## Summarize reads + OTUs by habitat and rank
summarise_rank <- function(rank_flag) {
  
  assigned_otus <- tax$OTU_ID[tax[[rank_flag]]]
  
  # READS
  reads_df <- lapply(levels(sam$habitat), function(h) {
    samp <- sam$SampleID[sam$habitat == h]
    
    tibble(
      habitat = h,
      total_reads = sum(otu_mat[, samp, drop = FALSE]),
      reads_assigned = sum(otu_mat[assigned_otus, samp, drop = FALSE])
    )
  }) |> bind_rows()
  
  # OTUs
  otus_df <- lapply(levels(sam$habitat), function(h) {
    samp <- sam$SampleID[sam$habitat == h]
    
    present <- rowSums(otu_mat[, samp, drop = FALSE]) > 0
    present_assigned <- rowSums(otu_mat[assigned_otus, samp, drop = FALSE]) > 0
    
    tibble(
      habitat = h,
      total_otus = sum(present),
      otus_assigned = sum(present_assigned)
    )
  }) |> bind_rows()
  
  # MERGE
  reads_df %>%
    left_join(otus_df, by = "habitat") %>%
    mutate(
      pct_reads_assigned = 100 * reads_assigned / total_reads,
      pct_otus_assigned  = 100 * otus_assigned  / total_otus
    )
}

tax_res_summary <- bind_rows(
  summarise_rank("assigned_phylum") %>% mutate(rank = "Phylum"),
  summarise_rank("assigned_class")  %>% mutate(rank = "Class"),
  summarise_rank("assigned_order")  %>% mutate(rank = "Order"),
  summarise_rank("assigned_genus")  %>% mutate(rank = "Genus")
)

tax_res_summary <- tax_res_summary %>%
  select(
    rank, habitat,
    total_reads, reads_assigned, pct_reads_assigned,
    total_otus,  otus_assigned,  pct_otus_assigned
  ) %>%
  arrange(rank, habitat)

print(tax_res_summary, n = Inf, width = Inf)

tax_res_summary <- tax_res_summary %>%
  mutate(
    rank = factor(rank, levels = c("Phylum","Class","Order","Genus")),
    habitat = factor(habitat, levels = c("Forest","Subpáramo","Páramo"))
  ) %>%
  arrange(rank, habitat)

print(tax_res_summary, n = Inf, width = Inf)

write_xlsx(
  tax_res_summary,
  path = "/data/lastexpansion/danieang/models/tax_assignment_summary_ps_fungi.xlsx"
)