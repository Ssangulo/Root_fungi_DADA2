---
title: "Appendix"
format: html
editor: visual
---

## Overview and reproducibility

This document compiles methodological details, supplementary analyses, and reproducibility outputs supporting the main manuscript. Computationally intensive steps (e.g. phylogenetic tree inference, GLLVM fitting, iNEXT3D diversity estimation) were executed on a remote Ubuntu-based computing environment. Their outputs (figures, tables, and selected model objects) are integrated here as static results.

All figures (PNG) and result tables (CSV) are stored within the project repository using relative paths. Rendering this document therefore requires cloning the repository and opening the .qmd file from the repository root.

**Data availability.**

Repository: To be provided upon acceptance\
Sequence data: ENA accession number PRJEB107725 \
Metadata: `Data_S1_metadata.csv, Data_S3_soil.csv`

```{r}

# Output folders used by table/figure chunks
out_fig_dir <- "figures"
out_tab_dir <- "tables"
out_obj_dir <- "objects"

# Main analysis phyloseq object (root-only; replicates collapsed; soil reads removed; decontam applied)
ps_individual <- readRDS(file.path(out_obj_dir, "ps_individual.rds"))


# Phyloseq object that includes the phylogeny and keeping the  2 root replicates separate
tree_ps  <- readRDS(file.path(out_obj_dir, "tree_ps.rds"))
```

## Study sites and sampling

This study was conducted across four humid páramo regions in the Colombian Andes, spanning the Central and Eastern Cordilleras. Sampling locations covered elevations from 2,715 to 3,828 m a.s.l., representing the ecological transition from Andean forest to páramo (see main text, Fig. 1). The full sample metadata table is provided in Data_S1_metadata.csv.

Root sampling followed standardized sterile procedures. Fine roots of Gaultheria myrsinoides were excavated using a spade, and 3–5 cm root tips were clipped using a sterilized pruner. Tools were disinfected with 75% ethanol between samples, and gloves were changed between individual plants to minimize contamination. Root fragments were placed into sealed polybags stored in ice-cooled containers in the field. Samples were processed at Universidad ICESI, where roots were rinsed in sterile water to remove debris, dried briefly under a laminar flow hood, and stored at –20°C prior to shipment to Norway, and long-term storage at –80°C. Soil samples (top 15 cm) were collected at each sampling location, and five aliquots of rinse water were retained as laboratory and transport controls.

**Table S1**: GPS coordinates, elevation, and vegetation type classification of the 12 sampling locations across four páramo regions. These sites span the forest–subpáramo–páramo gradient and were used for root and soil sampling.

|             |                      |                  |                  |                   |               |
|------------|------------|------------|------------|------------|------------|
| **Site ID** | **Site**             | **Altitude (m)** | **Latitude (N)** | **Longitude (W)** | **Ecosystem** |
| NV_1        | Páramo La Nevera     | 3828             | 03º30’58.1”      | 076º03’05.4”      | Páramo        |
| NV_2        | Páramo La Nevera     | 3550             | 03º31’37.7”      | 076º03’38.7”      | Subpáramo     |
| NV_3        | Páramo La Nevera     | 3333             | 03º32’07.0”      | 076º04’18.3”      | Andean forest |
| NV_4        | Páramo La Nevera     | 3078             | 03º32’48.9”      | 076º04’31.3”      | Andean forest |
| DOM_1       | Páramo Las Domínguez | 3815             | 03º43’51.8”      | 076º06’38.1”      | Páramo        |
| DOM_2       | Páramo Las Domínguez | 3534             | 03º44’07.2”      | 076º05’53.2”      | Subpáramo     |
| DOM_3       | Páramo Las Domínguez | 3234             | 03º44’17.1”      | 076º05’32.9”      | Andean forest |
| BEL_1       | Páramo Belmira       | 3254             | 06º38’43.8”      | 075º40’13.3”      | Subpáramo     |
| BEL_2       | Páramo Belmira       | 2950             | 06º38’22.7”      | 075º39’57.3”      | Andean forest |
| BEL_3       | Páramo Belmira       | 2715             | 06°36'55.3"      | 075°39'51.1"      | Andean forest |
| MA_1        | Páramo Matarredonda  | 3678             | 04º33’31.5”      | 074º01’43.8”      | Páramo        |
| MA_2        | Páramo Matarredonda  | 3381             | 04º33’10.3”      | 073º59’35.3”      | Subpáramo     |

## Bioinformatic pipeline and read-filtering summary

This section provides supplementary details on sequencing read processing and quality filtering. The full bioinformatic pipeline (including DADA2 processing and replicate filtering) is available in the project repository. Here we report summary tables of read retention and replicate-filtering thresholds used for downstream analyses.

**Table S2**: Median read numbers per PCR replicate for environmental samples (root and soil samples) and controls (blank extractions, positive, PCR blank, and tag-jump controls). The read counts are grouped at each stage of the DADA2 pipeline. Blank extraction controls (not containing any biological sample) were performed alongside real sample DNA extractions per each extraction batch. PCR blank controls contained all PCR reagents but no DNA template. Tag-jump controls are PCR reactions containing no primers and no DNA template, used to detect tag-jumping (index hopping). 

|                               |               |              |                         |                     |                           |
|------------|------------|------------|------------|------------|------------|
|                               | **Raw reads** | **Filtered** | **Merged - Non pooled** | **Merged - Pooled** | **Merged - Pseudopooled** |
| **Root samples**              | 77,047        | 71,783       | 71,084                  | 70,343              | 71,242                    |
| **Soil samples**              | 72,158        | 66,555       | 65,311                  | 65,498              | 65,385                    |
| **Blank Extraction Controls** | 2,844         | 2,652        | 2,618                   | 2,566               | 2,625                     |
| **Positive Controls**         | 95,238        | 88,174       | 88,062                  | 87,996              | 87,972                    |
| **PCR Blank Controls**        | 291           | 261          | 250                     | 257                 | 256                       |
| **Tag-jump Controls**         | 41            | 36           | 27                      | 30                  | 32                        |

------------------------------------------------------------------------

```{r}
#| echo: false
library(knitr)

tab_s3 <- read.csv("tables/Table_S3_OTU_filtering_summary.csv", check.names = FALSE)

kable(
  tab_s3,
  caption = "Table S3. Number of OTUs and samples after applying different replicate control filtering thresholds. The table shows results for both soil and root samples combined and only root samples."
)
```

------------------------------------------------------------------------

**Table S4**: Summary of the percentage of reads and OTUS with confident taxonomic assignment at each taxonomic rank, represented by habitat. Percentages were calculated from the filtered root-only dataset (soil reads removed).

|          |             |                       |                      |
|----------|-------------|-----------------------|----------------------|
| **Rank** | **Habitat** | **%\_reads_assigned** | **%\_otus_assigned** |
| Phylum   | Forest      | 88,1                  | 88,1                 |
| Phylum   | Subpáramo   | 91,6                  | 88,6                 |
| Phylum   | Páramo      | 92,9                  | 89,3                 |
| Class    | Forest      | 78,3                  | 72,5                 |
| Class    | Subpáramo   | 84,2                  | 72,3                 |
| Class    | Páramo      | 84,3                  | 76,0                 |
| Order    | Forest      | 68,3                  | 59,2                 |
| Order    | Subpáramo   | 74,2                  | 57,1                 |
| Order    | Páramo      | 78,2                  | 60,9                 |
| Genus    | Forest      | 32,8                  | 34,2                 |
| Genus    | Subpáramo   | 32,1                  | 32,2                 |
| Genus    | Páramo      | 31,4                  | 32,7                 |

## Taxonomic composition of root and soil communities

![](figures/FigS1_Venn.png)

**Figure S1**: Venn diagram of taxonomic assignments across sampling sites, in the root only dataset, but previous to soil sequences removal. Venn diagrams illustrate the overlap of OTU taxonomic assignments across four study sites: La Nevera (NV), Las Domínguez (DOM), Belmira (BEL), and Matarredonda (MA). Only OTUs with confirmed assignments at each taxonomic level are included.

------------------------------------------------------------------------

![](figures/FigS2.png)

**Figure S2**: Taxonomic composition in root samples along the elevational gradient. Relative read abundances are shown at two taxonomic ranks:  A) Class and B) Genus. Each bar represents an individual root sample, grouped by habitat: Forest (2700-3300 m), Subpáramo (3300-3500 m), and Páramo (3800 m). Study sites are indicated on the y-axis. *Code: see "MicroViz code for taxonomic barplots" below.*

------------------------------------------------------------------------

![](figures/FigS3.png)

**Figure S3**: Taxonomic composition in soil samples, collected at each of the sampling locations. Relative read abundances are shown at three taxonomic ranks:  A) Phylum, B) Genus, and C) Order. Each bar represents an individual root sample, grouped by habitat: Forest (2700-3300 m), Subpáramo (3300-3500 m), and Páramo (3800 m). Study sites are indicated on the y-axis. *Code: see "MicroViz code for taxonomic barplots" below.*

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "MicroViz code for taxonomic barplots (executed on server)"

# MicroViz taxonomic barplots
# Code executed on remote server; plots saved as PNG and embedded above.

library(microViz)

filter_taxa_by_rank <- function(physeq_obj, rank_prefix = "o__", exclude_term = "Incertae_sedis") {
  taxa_assigned <- grepl(rank_prefix, tax_table(physeq_obj)[, "Order"])
  exclude_incertae_sedis <- !grepl(exclude_term, tax_table(physeq_obj)[, "Order"])
  taxa_filtered <- taxa_assigned & exclude_incertae_sedis
  physeq_filtered <- prune_taxa(taxa_filtered, physeq_obj)
  return(physeq_filtered)
}

ps_filtered <- filter_taxa_by_rank(alldat.N[[2]])

# Clean taxonomic prefixes like o__, g__, etc.
tax_table(ps_filtered) <- apply(
  tax_table(ps_filtered), 2, function(x) gsub("^[a-z]__", "", x)
)

# Recode habitat labels
sample_data(ps_filtered)$habitat <- dplyr::recode(
  as.character(sample_data(ps_filtered)$habitat),
  "forest"    = "Forest",
  "subparamo" = "Subpáramo",
  "paramo"    = "Páramo",
  .default = NA_character_
)


# Order the factor levels
sample_data(ps_filtered)$habitat <- factor(
  sample_data(ps_filtered)$habitat,
  levels = c("Forest","Subpáramo","Páramo"),
  ordered = TRUE
)

ps_filtered <- ps_filtered %>% ps_arrange(site)

#  within each site, order samples by Bray/OLO seriation at Order level ---
site_levels <- sample_data(ps_filtered) %>% as.data.frame() %>% pull(site) %>% unique()

samp_order <- unlist(lapply(site_levels, function(s) {
  ps_filtered %>%
    ps_filter(site == s) %>%
    ps_seriate(rank = "Order") %>%   # same tax_level you plot
    sample_names()                   # returns samples in seriated order
}))

# Barplot faceted by habitat, clean legend labels
p <- ps_filtered %>%
  comp_barplot(
    tax_level = "Order", n_taxa = 10, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other orders"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )




#Plot for phylum
phy <- ps_filtered %>%
  comp_barplot(
    tax_level = "Phylum", n_taxa = 5, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other phyla"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )



#Plot for class
class <- ps_filtered %>%
  comp_barplot(
    tax_level = "Class", n_taxa = 10, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other classes"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )



#Plot for genus
genus <- ps_filtered %>%
  comp_barplot(
    tax_level = "Genus", n_taxa = 20, label = "site",
    bar_outline_colour = "grey5", facet_by = "habitat", sample_order = samp_order,   
    merge_other = FALSE, other_name = "Other genera"
  ) +
  coord_flip() +
  theme(
    legend.text  = element_text(size = 6),
    legend.title = element_text(size = 7),
    legend.key.size = unit(0.3, "cm"),
    legend.spacing.x = unit(0.2, "cm"),
    plot.title = element_text(hjust = 0.5)
  )


```

# Community composition analyses

This section provides detailed statistical analyses supporting the patterns of root-associated fungal community composition described in the main text. Several of these analyses form the basis of results reported in the main manuscript; here we document the full model specifications, test statistics, and complementary ordinations to ensure transparency and reproducibility.

We include distance-based redundancy analysis (dbRDA) based on robust Aitchison distances to assess habitat-associated compositional structure while conditioning on site. We further present PERMANOVA results from a balanced subset of samples (NV–DOM) used to test habitat and site effects under a controlled sampling design. In addition, we report a centroid-based turnover model quantifying the magnitude of community change across habitats using the full dataset.

### Multivariate ordination

Distance-based redundancy analysis (dbRDA) was conducted on robust Aitchison distances to test for habitat-associated compositional structure while conditioning on site.

![](figures/Fig_S4.png)

**Figure S4**: Distance-based redundancy analysis (dbRDA) of root-associated fungal communities based on robust Aitchison distances. Points are colored by habitat; site was included as a conditioning variable. *Code: see "Code used to generate Figure S4 and Table S5" below.*

------------------------------------------------------------------------

```{r}
#| echo: false
library(knitr)

tab_terms <- read.csv("tables/Table_S5_dbRDA_terms.csv")
kable(tab_terms, digits = 3,
      caption = "Table S5a. dbRDA permutation tests (by term; 999 permutations).")
```

```{r}
#| echo: false
tab_axis <- read.csv("tables/Table_S5_dbRDA_axes.csv")
kable(tab_axis, digits = 3,
      caption = "Table S5b. dbRDA permutation tests (by constrained axis; 999 permutations).")
```

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "Code used to generate Figure S4 and Table S5 (executed on server)"

#Running dbRDA with robust aitchison
library(phyloseq)
library(vegan)
library(knitr)


ps <- ps_individual #phyloseq object

X <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) X <- t(X)

sam <- data.frame(sample_data(ps))
sam$habitat <- factor(sam$habitat)
sam$site    <- factor(sam$site)


# dbRDA model: habitat constrained, conditioning on site
d_ait <- vegdist(otu_table(ps), binary=FALSE, method="robust.aitchison")
mod_ait <- capscale(d_ait ~ habitat + Condition(site), data = sam)

# Permutation tests (999 permutations)
set.seed(1)
a_terms   <- anova.cca(mod_ait, by = "terms", permutations = 999)
a_axis    <- anova.cca(mod_ait, by = "axis", permutations = 999)


a_terms
a_axis

tab_terms <- data.frame(
  Term = rownames(a_terms),
  Df = a_terms$Df,
  Variance = a_terms$Variance,
  F = a_terms$F,
  Pr = a_terms$`Pr(>F)`,
  row.names = NULL
)

tab_axis <- data.frame(
  Axis = rownames(a_axis),
  Df = a_axis$Df,
  Variance = a_axis$Variance,
  F = a_axis$F,
  Pr = a_axis$`Pr(>F)`,
  row.names = NULL
)

write.csv(tab_terms, "Table_S4_dbRDA_terms.csv", row.names = FALSE)
write.csv(tab_axis,  "Table_S4_dbRDA_axes.csv",  row.names = FALSE)


# Plotting Figure S4 
eig <- mod_ait$CCA$eig
cap1_pct <- round(100 * eig[1] / sum(eig), 1)
cap2_pct <- round(100 * eig[2] / sum(eig), 1)

cols <- c(forest="steelblue", subparamo="seagreen3", paramo="firebrick")

png("FigS4_dbRDA.png", width=7.2, height=6.2, units="in", res=600)
par(mar=c(4.5,4.5,1,1))
plot(mod_ait, display="sites", type="n",
     xlab=paste0("dbRDA1 (",cap1_pct,"%)"),
     ylab=paste0("dbRDA2 (",cap2_pct,"%)"))
pts <- scores(mod_ait, display="sites")
points(pts, pch=16, cex=0.7, col=cols[as.character(sam$habitat)])
legend("topright", bty="n", legend=levels(sam$habitat),
       col=cols[levels(sam$habitat)], pch=16, pt.cex=0.9)
dev.off()

```

### PERMANOVA and dispersion analyses

Beta-dispersion tests indicated higher within-habitat variability in forests compared with subpáramo and páramo communities (p \< 0.001), whereas dispersion did not differ among sites (p = 0.526). Because the PERMANOVA was conducted on a balanced subset of samples, the significant effects of habitat, site, and their interaction are interpreted as reflecting genuine compositional differences rather than artifacts of unequal dispersion. *Code: see "Code used to generate Tables S6a-S6c" below.*

```{r}
#| echo: false
library(knitr)

tab_s6 <- read.csv("tables/Table_S6_PERMANOVA.csv")
kable(tab_s6, digits = 3, caption = "Table S6a. PERMANOVA (adonis2) results by term.")
```

```{r}
#| echo: false
disp_hab <- read.csv("tables/Table_S6_dispersion_habitat.csv")
test_hab <- read.csv("tables/Table_S6_betadisper_test_habitat.csv")

kable(disp_hab, digits = 3,
      caption = paste0("Table S6b. Habitat beta-dispersion (distance to centroid). Permutation test p = ",
                       signif(test_hab$p_value[1], 3), "."))
```

```{r}
#| echo: false
test_site <- read.csv("tables/Table_S6_betadisper_test_site.csv")

kable(test_site, digits = 3,
      caption = "Table S6c. Site beta-dispersion permutation test.")
```

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "Code used to generate Tables S6a–S6c (executed on server)"

ps <- individual_ps #phyloseq obj

# Balanced subset: NV + DOM, remove NV_4
balanced_ps <- subset_samples(ps, site %in% c("DOM", "NV"))
balanced_ps <- subset_samples(balanced_ps, site_elevation != "NV_4")
balanced_ps <- prune_taxa(taxa_sums(balanced_ps) > 0, balanced_ps)

# Ensure samples are rows
X <- as(otu_table(balanced_ps), "matrix")
if (taxa_are_rows(balanced_ps)) X <- t(X)

sampledf <- data.frame(sample_data(balanced_ps))
sampledf$site    <- factor(sampledf$site)
sampledf$habitat <- factor(sampledf$habitat)

# Robust Aitchison distance
dists <- vegdist(X, method = "robust.aitchison")

# PERMANOVA (by terms)
set.seed(1)
perma <- adonis2(dists ~ site * habitat, by = "terms", data = sampledf, permutations = 999)

# Convert output to a clean CSV table
tab_perma <- data.frame(
  Source   = rownames(perma),
  df       = perma$Df,
  SumOfSqs = perma$SumOfSqs,
  R2       = perma$R2,
  `Pseudo-F` = perma$F,
  `Pr(>F)` = perma$`Pr(>F)`,
  row.names = NULL
)

# Beta-dispersion (habitat & site)
bd_hab  <- betadisper(dists, sampledf$habitat)
bd_site <- betadisper(dists, sampledf$site)

set.seed(1)
pt_hab  <- permutest(bd_hab,  permutations = 999)
pt_site <- permutest(bd_site, permutations = 999)

# Group dispersions 
disp_hab <- data.frame(
  habitat = names(bd_hab$group.distances),
  avg_distance_to_centroid = as.numeric(bd_hab$group.distances),
  row.names = NULL
)

disp_site <- data.frame(
  site = names(bd_site$group.distances),
  avg_distance_to_centroid = as.numeric(bd_site$group.distances),
  row.names = NULL
)


test_hab <- data.frame(
  test = "betadisper_habitat",
  permutations = 999,
  F = unname(pt_hab$tab[1, "F"]),
  p_value = unname(pt_hab$tab[1, "Pr(>F)"])
)

test_site <- data.frame(
  test = "betadisper_site",
  permutations = 999,
  F = unname(pt_site$tab[1, "F"]),
  p_value = unname(pt_site$tab[1, "Pr(>F)"])
)

# Output paths
out_dir <- "/data/lastexpansion/_ang/objects"
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)

write.csv(tab_perma,  file.path(out_dir, "Table_S6_PERMANOVA.csv"), row.names = FALSE)
write.csv(disp_hab,   file.path(out_dir, "Table_S6_dispersion_habitat.csv"), row.names = FALSE)
write.csv(disp_site,  file.path(out_dir, "Table_S6_dispersion_site.csv"), row.names = FALSE)
write.csv(test_hab,   file.path(out_dir, "Table_S6_betadisper_test_habitat.csv"), row.names = FALSE)
write.csv(test_site,  file.path(out_dir, "Table_S6_betadisper_test_site.csv"), row.names = FALSE)


```

## Centroid-based turnover model

To quantify the magnitude of community turnover across habitats while accounting for spatial structure, we calculated the Aitchison distance of each sample to its site-specific centroid and modelled turnover as a function of habitat, site, and their interaction. Habitat had a strong effect on turnover magnitude, whereas the habitat × site interaction was not significant, indicating consistent habitat-associated turnover across geographically isolated páramo regions (Table S7).

**Table S7**: Linear model results for centroid-based turnover.

```{r}
#| echo: false
library(knitr)

tab_s7 <- read.csv("tables/Table_S7_centroid_model.csv")
kable(tab_s7, digits = 3)

```

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "Code used to generate Table S7 (executed on server)"

library(phyloseq)
library(vegan)


ps <- individual_ps #phyloseq obj


# OTU table -> samples x taxa
X <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) X <- t(X)
X <- as.matrix(X)

# Robust CLR
rfy <- decostand(X, "rclr", MARGIN = 1)

# Metadata
meta <- data.frame(sample_data(ps), check.names = FALSE, stringsAsFactors = FALSE)
stopifnot(identical(rownames(rfy), rownames(meta)))

# Site centroids in CLR space
centroids <- rowsum(rfy, group = meta$site) / as.vector(table(meta$site))

# Euclidean distance to site centroid
euclid <- function(x, y) sqrt(sum((x - y)^2))

dist_centroid <- vapply(
  seq_len(nrow(rfy)),
  function(i) euclid(rfy[i, ], centroids[meta$site[i], ]),
  numeric(1)
)

# Model dataframe
df <- meta
df$dist_centroid <- dist_centroid
df$site <- factor(df$site)
df$habitat <- factor(df$habitat, levels = c("forest", "subparamo", "paramo"))

# Linear model (habitat-based)
mod_hab <- lm(dist_centroid ~ habitat * site, data = df)

# ANOVA table
a <- anova(mod_hab)

tab_s7 <- data.frame(
  Effect = rownames(a),
  df = a$Df,
  `Sum of Squares` = a$`Sum Sq`,
  `Mean Square` = a$`Mean Sq`,
  `F value` = a$`F value`,
  `p value` = a$`Pr(>F)`,
  row.names = NULL
)

# Output
out <- "/data/lastexpansion/_ang/objects/Table_S7_centroid_model.csv"
dir.create(dirname(out), showWarnings = FALSE, recursive = TRUE)
write.csv(tab_s7, out, row.names = FALSE)

```

### Abundance-based beta diversity partitioning

Bray–Curtis dissimilarities were partitioned into balanced variation and abundance gradients across taxonomic levels using the `betapart` package. Metrics were calculated from rarefied abundance data.

```{r}
#| echo: false
library(knitr)

tab_s8 <- read.csv("tables/Table_S8_Bray_partitioning.csv")

kable(
  tab_s8,
  digits = 4,
  caption = "Table S8. Bray–Curtis beta-diversity partitioning across taxonomic levels and sites."
)
```

## Beta-regression models

To quantify elevational trends in the relative abundance of dominant fungal lineages, we fitted beta-regression models to order-level relative read abundances. Models were fitted separately for each order using a logit link, with elevation as a continuous predictor and site included as a fixed effect. Relative abundances were calculated as proportions of total reads per sample and transformed using a Smithson–Verkuilen adjustment.

We focus on helotiales and sebacinales, the two most abundant orders, which also showed the only significant elevation responses. For both orders, fitted relationships and raw data are shown in Figure 2, while full model summaries are provided in Table S9. Elevation effects for the eight most abundant orders are summarized in Table S10.

Model diagnostics were examined to assess fit and identify potential violations of distributional assumptions. Diagnostic plots include Pearson residuals versus fitted values and elevation, quantile residual Q–Q plots, and leverage values (Figures S6–S7).

**Table S9**:

```{r}
#| echo: false
library(knitr)

tab_s9_helot <- read.csv("tables/Table_S9_betareg_helotiales.csv")
kable(tab_s9_helot, digits = 4,
      caption = "Table S9a. Beta regression summary for helotiales (mean model coefficients and precision (phi)).")
```

```{r}
#| echo: false
tab_s9_seba <- read.csv("tables/Table_S9_betareg_sebacinales.csv")
kable(tab_s9_seba, digits = 4,
      caption = "Table S9b. Beta regression summary for sebacinales (mean model coefficients and precision (phi)).")
```

------------------------------------------------------------------------

**Table S10**:

```{r}
#| echo: false
library(knitr)

tab_s10 <- read.csv("tables/Table_S10_betareg_elevation_effects.csv")
kable(tab_s10, digits = 4,
      caption = "Table S10. Elevation effects from beta regression models for the dominant orders (mean submodel), with pseudo-R².")
```

------------------------------------------------------------------------

![](figures/Fig_S7_betareg_diagnostics_helotiales.png)

**Figure S6**: Diagnostic plots for the beta-regression model of Helotiales. *Code: see "Beta-regression models" below.*

------------------------------------------------------------------------

![](figures/Fig_S8_betareg_diagnostics_sebacinales.png)

**Figure S7**: Diagnostic plots for the beta-regression model of Sebacinales. *Code: see "Beta-regression models" below.*

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "Beta-regression models (executed on remote server)"

# This code fits beta-regression models for dominant fungal orders,
# generates Tables S9–S10, and exports Figures 2a and S6–S7 as PNG files.

library(phyloseq)
library(dplyr)
library(tidyr)
library(ggplot2)
library(betareg)
library(patchwork)


out_fig_dir <- "/data/lastexpansion/_ang/objects" 
out_tab_dir <- "/data/lastexpansion/_ang/objects" 

set.seed(1)

## ---- Helper: build beta-regression dataframe for an Order ----
make_beta_df_from_order <- function(ps, order_name) {

  otu <- as(otu_table(ps), "matrix")
  if (!taxa_are_rows(ps)) otu <- t(otu)  # taxa x samples

  sd <- as.data.frame(sample_data(ps))
  sd <- sd[colnames(otu), , drop = FALSE]  # force alignment

  tax <- as.data.frame(tax_table(ps), stringsAsFactors = FALSE)
  stopifnot("Order" %in% names(tax))

  order_vec <- tolower(as.character(tax$Order))
  order_vec[is.na(order_vec)] <- ""

  otu_ids <- rownames(tax)[grepl(tolower(order_name), order_vec, fixed = TRUE)]
  if (length(otu_ids) == 0) stop(paste("No OTUs found for", order_name))

  counts <- colSums(otu[otu_ids, , drop = FALSE])
  total  <- colSums(otu)

  samps <- colnames(otu)

  df <- data.frame(
    sample    = samps,
    count     = as.numeric(counts),
    total     = as.numeric(total),
    prop_raw  = ifelse(total > 0, counts / total, NA_real_),
    site      = sd[, "site", drop = TRUE],
    elevation = sd[, "elevation", drop = TRUE],
    stringsAsFactors = FALSE
  )

  # Smithson–Verkuilen adjustment to (0,1)
  n <- nrow(df)
  df$Proportion <- (df$prop_raw * (n - 1) + 0.5) / n

  df$site <- factor(df$site)
  df$elevation <- as.numeric(df$elevation)

  df
}

## ---- Helper: tidy coefficient table for Table S8 ----
tidy_betareg_mean <- function(mod, model_name) {
  sm <- summary(mod)
  co <- as.data.frame(sm$coefficients$mean)
  co$Term <- rownames(co)
  rownames(co) <- NULL
  names(co) <- c("Estimate","SE","z","p","Term")

  # move Term first + add model label
  co <- co %>%
    select(Term, Estimate, SE, z, p) %>%
    mutate(Model = model_name, .before = 1)

  # also add phi (precision) row, for completeness
  phi <- as.data.frame(sm$coefficients$precision)
  phi$Term <- rownames(phi); rownames(phi) <- NULL
  names(phi) <- c("Estimate","SE","z","p","Term")
  phi <- phi %>%
    select(Term, Estimate, SE, z, p) %>%
    mutate(Model = model_name, .before = 1) %>%
    mutate(Term = paste0(Term, " (phi)"))

  bind_rows(co, phi)
}

## ---- Helper: elevation-only summary across orders for Table S9 ----
extract_elev <- function(mod, order_name) {
  sm <- summary(mod)
  co <- sm$coefficients$mean
  if (!("elevation" %in% rownames(co))) return(NULL)
  data.frame(
    order = order_name,
    term  = "elevation",
    estimate  = co["elevation","Estimate"],
    se        = co["elevation","Std. Error"],
    z         = co["elevation","z value"],
    p_value   = co["elevation","Pr(>|z|)"],
    pseudo_R2 = sm$pseudo.r.squared,
    stringsAsFactors = FALSE
  )
}

## ---- 1) Fit models ----
orders_target <- c(
  "helotiales",
  "sebacinales",
  "chaetothyriales",
  "sclerococcales",
  "agaricales",
  "pleosporales",
  "hypocreales",
  "leotiales"
)

df_list  <- setNames(vector("list", length(orders_target)), orders_target)
mod_list <- setNames(vector("list", length(orders_target)), orders_target)

for (ord in orders_target) {
  message("Building DF + fitting: ", ord)
  df_list[[ord]]  <- make_beta_df_from_order(ps, ord)
  mod_list[[ord]] <- betareg(Proportion ~ elevation + site, data = df_list[[ord]])
}

## ---- 2) Table S9: helotiales + sebacinales full model tables ----
tab_s9_helot <- tidy_betareg_mean(mod_list[["helotiales"]], "helotiales")
tab_s9_seba  <- tidy_betareg_mean(mod_list[["sebacinales"]], "sebacinales")

write.csv(tab_s9_helot,
          file.path(out_tab_dir, "Table_S9_betareg_helotiales.csv"),
          row.names = FALSE)
write.csv(tab_s9_seba,
          file.path(out_tab_dir, "Table_S9_betareg_sebacinales.csv"),
          row.names = FALSE)

## ---- 3) Table S10: elevation effects across orders ----
tab_s10 <- bind_rows(lapply(names(mod_list), \(ord) extract_elev(mod_list[[ord]], ord)))
write.csv(tab_s10,
          file.path(out_tab_dir, "Table_S10_betareg_elevation_effects.csv"),
          row.names = FALSE)



## ---- 4) Beta regression plots for Helotiales + Sebacinales ----

# helper
inv_logit <- function(x) 1 / (1 + exp(-x))

plot_betareg_with_raw <- function(model, data, label_prefix = "helotiales") {

  # Ensure required columns exist
  stopifnot(all(c("site","elevation","prop_raw") %in% names(data)))

  data <- data[complete.cases(data[, c("site","elevation","prop_raw")]), , drop = FALSE]

  # Align site factor levels to model
  if (!is.null(model$xlevels$mean$site)) {
    data$site <- factor(as.character(data$site), levels = model$xlevels$mean$site)
  } else {
    data$site <- factor(data$site)
  }

  # Drop any rows that became NA due to level mismatch
  data <- data[!is.na(data$site), , drop = FALSE]

  one_level_site <- (nlevels(droplevels(data$site)) < 2)

  # Build prediction grid by site across observed elevation range
  newdat <- data %>%
    dplyr::select(site, elevation) %>%
    dplyr::distinct() %>%
    dplyr::group_by(site) %>%
    dplyr::summarize(
      elev_min = min(elevation, na.rm = TRUE),
      elev_max = max(elevation, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(elevation = list(seq(elev_min, elev_max, length.out = 100))) %>%
    tidyr::unnest(elevation) %>%
    dplyr::select(site, elevation) %>%
    dplyr::ungroup()

  # Re-apply model levels to newdat site
  if (!is.null(model$xlevels$mean$site)) {
    newdat$site <- factor(as.character(newdat$site), levels = model$xlevels$mean$site)
  } else {
    newdat$site <- factor(newdat$site)
  }

  # If we only have 1 site level, disable contrasts to prevent the error
  if (one_level_site) {
    contrasts(newdat$site) <- NULL
  }

  # Design matrix for mean submodel
  mean_terms <- stats::delete.response(stats::terms(model, model = "mean"))
  X <- model.matrix(mean_terms, newdat)

  beta <- coef(model, model = "mean")
  V <- try(vcov(model, model = "mean"), silent = TRUE)
  if (inherits(V, "try-error")) V <- vcov(model)

  eta    <- as.vector(X %*% beta)
  se_eta <- sqrt(rowSums((X %*% V) * X))

  newdat$fit <- inv_logit(eta)
  newdat$lwr <- inv_logit(eta - 1.96 * se_eta)
  newdat$upr <- inv_logit(eta + 1.96 * se_eta)

  # Plot
  ggplot() +
    geom_point(
      data = data,
      aes(x = elevation, y = prop_raw, colour = site),
      size = 2, alpha = 0.7
    ) +
    geom_ribbon(
      data = newdat,
      aes(x = elevation, ymin = lwr, ymax = upr, fill = site, group = site),
      alpha = 0.15, colour = NA
    ) +
    geom_line(
      data = newdat,
      aes(x = elevation, y = fit, colour = site, group = site),
      linewidth = 0.8
    ) +
    scale_y_continuous("Relative abundance (raw proportion)", limits = c(0, 1)) +
    scale_x_continuous("Elevation (m)") +
    ggtitle(label_prefix) +
    theme_bw(base_size = 10) +
    theme(
      plot.title = element_text(face = "bold", size = 12, hjust = 0),
      legend.position = "bottom"
    )
}

# Build plots
p_helot <- plot_betareg_with_raw(mod_list[["helotiales"]], df_list[["helotiales"]], "A) helotiales")
p_seba  <- plot_betareg_with_raw(mod_list[["sebacinales"]], df_list[["sebacinales"]], "B) sebacinales")

# Combine and save
panel_beta <- (p_helot | p_seba) + patchwork::plot_layout(guides = "collect")

ggsave(
  filename = file.path(out_fig_dir, "Fig_2a_beta_regression_panel.png"),
  plot = panel_beta,
  width = 12, height = 5.5, dpi = 800
)


## ---- 5) Diagnostic plots for Helotiales + Sebacinales ----

plot_betareg_diagnostics <- function(model, data, label_prefix = "Helotiales") {

  # Ensure alignment (betareg expects the same row order it was fitted with)
  data <- data[complete.cases(data[, c("elevation","site","Proportion")]), , drop = FALSE]

  # residuals & fitted
  res_pear  <- residuals(model, type = "pearson")
  res_quant <- residuals(model, type = "quantile")   # approx N(0,1)
  fit       <- fitted(model)
  hatv      <- hatvalues(model)

  diagdf <- data.frame(
    fitted    = fit,
    res_pear  = res_pear,
    res_quant = res_quant,
    elevation = data$elevation,
    site      = as.factor(data$site),
    hat       = hatv,
    idx       = seq_len(nrow(data))
  )

  # (1) Residuals vs Fitted
  p1 <- ggplot(diagdf, aes(fitted, res_pear)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
    geom_point(alpha = 0.7, size = 1.8) +
    geom_smooth(method = "loess", se = FALSE, linewidth = 0.5) +
    labs(x = "Fitted values", y = "Pearson residuals",
         title = paste(label_prefix, "– Residuals vs Fitted")) +
    theme_bw(base_size = 9)

  # (2) Residuals vs Elevation
  p2 <- ggplot(diagdf, aes(elevation, res_pear)) +
    geom_hline(yintercept = 0, linetype = "dashed", color = "grey40") +
    geom_point(alpha = 0.7, size = 1.8) +
    geom_smooth(method = "loess", se = FALSE, linewidth = 0.5) +
    labs(x = "Elevation (m)", y = "Pearson residuals",
         title = paste(label_prefix, "– Residuals vs Elevation")) +
    theme_bw(base_size = 9)

  # (3) Q–Q plot of quantile residuals
  p3 <- ggplot(diagdf, aes(sample = res_quant)) +
    stat_qq(size = 1.4, alpha = 0.8) +
    stat_qq_line() +
    labs(title = paste(label_prefix, "– Q–Q Plot (quantile residuals)"),
         x = "Theoretical quantiles", y = "Sample quantiles") +
    theme_bw(base_size = 9)

  # (4) Leverage
  hat_thr <- 2 * mean(diagdf$hat, na.rm = TRUE)
  p4 <- ggplot(diagdf, aes(idx, hat)) +
    geom_point(alpha = 0.85, size = 1.8) +
    geom_hline(yintercept = hat_thr, color = "red", linetype = "dashed") +
    labs(x = "Observation index", y = "Leverage (hat values)",
         title = paste(label_prefix, "– Leverage")) +
    theme_bw(base_size = 9)

  (p1 | p2) / (p3 | p4) +
    patchwork::plot_annotation(title = paste(label_prefix, "model diagnostics")) &
    theme(plot.title = element_text(face = "bold", size = 10, hjust = 0))
}

# Use your existing objects from Steps 1–3
diag_helot <- plot_betareg_diagnostics(mod_list[["helotiales"]],  df_list[["helotiales"]],  "Helotiales")
diag_seba  <- plot_betareg_diagnostics(mod_list[["sebacinales"]], df_list[["sebacinales"]], "Sebacinales")

ggsave(
  filename = file.path(out_fig_dir, "Fig_S6_betareg_diagnostics_helotiales.png"),
  plot = diag_helot, width = 8.5, height = 6.5, dpi = 600
)

ggsave(
  filename = file.path(out_fig_dir, "Fig_S7_betareg_diagnostics_sebacinales.png"),
  plot = diag_seba, width = 8.5, height = 6.5, dpi = 600
)

```

## Functional annotation with FUNGuild

Functional guilds from root samples were assigned using FUNGuild based on the curated taxonomic strings exported from the phyloseq object. OTUs with a valid confidence ranking in the FUNGuild output were retained for downstream summaries. Guild labels were additionally collapsed into a primary-guild hierarchy (Ericoid mycorrhizal \> other mycorrhizal \> endophyte \> pathotroph \> saprotroph \> other) to simplify interpretation. Figure S8 summarizes mean guild-associated read abundance per sample across habitats.

![](figures/Fig_S9_FunGuild.png)

**Figure S8**: Mean relative read abundance per sample of fungal functional guilds across forest, subpáramo, and páramo habitats, based on FUNGuild annotations. Only root samples. *Code: see "FUNGuild functional annotation" below.*

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "FUNGuild functional annotation (external script)"

# Functional guild assignment was performed using FUNGuild prior to figure generation.
#
# The full annotation workflow is available in the GitHub repository:
#   scripts/funguild_script.R
#
# Input:
#  - Taxonomically annotated ASV/OTU table
#
# Output:
#  - Table of guild assignments per taxon
#  - Mean read abundances per sample and habitat
#
# Figure S8 was generated from these outputs and is included above as a PNG.
```

## Generalized Linear Latent Variable Model (GLLVM)

We modelled OTU counts using a generalized linear latent variable model (GLLVM; negative binomial distribution, log link), with habitat (forest, subpáramo, páramo) as a fixed effect, log library size as an offset, and random intercepts for site and individual plants (Unique_ID). One latent variable was included to account for residual correlation among taxa. The final model (log-likelihood = −37,616; AIC = 80,295) provided the best balance between fit and parsimony. It substantially outperformed earlier versions with nested random effects (AIC = 186,832), and attempts to increase the number of latent variables to two worsened performance (ΔAIC ≈ 12,700) and produced a singular information matrix, indicating over-parameterization. Simplifying the random-effects structure and filtering rare taxa also improved convergence and reduced overdispersion while retaining ecological signal.

Model fit was evaluated using Dunn–Smyth residual diagnostics (Fig. S9). Habitat coefficients (β) were extracted for each OTU from the fixed-effects matrix. To obtain genus-level responses, OTUs were restricted to those assigned to a genus (excluding incertae sedis) and weighted by their total read abundance across samples. For each genus, we computed the abundance-weighted mean β for páramo and subpáramo relative to forest. Uncertainty was summarized using a weighted bootstrap (R = 500) resampling OTUs within genera with probabilities proportional to total abundance; 2.5–97.5% quantiles were used as 95% confidence intervals. These summaries were used to generate the heatmap and barplot shown in Figure 4. The full OTU-level coefficient table is provided in Data_S2_GLLVM_table.csv.

![](figures/Fig_S10_GLLVM_diagnostics.png)

**Figure S9**: Diagnostic plots for the negative-binomial GLLVM (Dunn–Smyth residuals). *Code: see "GLLVM model fitting + coefficient summaries" below.*

For transparency, we provide a short preview of the genus-level GLLVM summaries below. The complete OTU- and genus-level coefficient table is available as Data S2 (Data_S2_GLLVM_table.csv).

```{r}
#| echo: false
library(knitr)

gllvm_tab <- read.csv("tables/File_S2_GLLVM_table.csv")

kable(
  gllvm_tab[1:10, c(
    "Order", "Genus", "n_OTUs",
    "w_mean_beta_paramo", "w_mean_beta_subparamo",
    "perc_enriched_paramo_w", "perc_enriched_subparamo_w"
  )],
  digits = 3,
  caption = "Data S2 (preview). Selected columns from the GLLVM genus-level summary. The full table with all metrics is provided as a CSV file."
)
```

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "GLLVM model fitting + coefficient summaries (executed on server)"

# GLLVM analysis was executed on the server due to computational cost.
# The complete workflow (data filtering, model fitting, diagnostics, and genus-level summaries) is provided in the repository:
#   scripts/gllvm_analysis.R
#
# Key outputs saved:
#   - figures/Fig_S9_GLLVM_diagnostics.png
#   - tables/File_S2_GLLVM_table.csv
#   - objects/fit_nb_2.rds  # fitted model object
```

## Diversity analyses with iNEXT3D

We quantified habitat-associated patterns in taxonomic diversity (TD) and phylogenetic diversity (PD) using iNEXT3D and Hill numbers (q = 0, 1, 2). Diversity estimates were computed from incidence (presence/absence) matrices at the habitat level and evaluated under rarefaction/extrapolation with bootstrap confidence intervals (nboot = 500). Phylogenetic diversity was estimated as meanPD using a pruned phylogeny matched to the observed taxa. Diversity curves are presented in the main text (Fig. 4), while asymptotic summaries are provided here (Tables S11–S12).

```{r}
#| echo: false
library(knitr)

tab_s11 <- read.csv("tables/Table_S11_iNEXT3D_taxonomic_diversity.csv")

kable(
  tab_s11,
  digits = 3,
  caption = "Table S11. Taxonomic diversity (TD) summary from iNEXT3D across habitats (q = 0, 1, 2; nboot = 500). Observed and asymptotic estimates are reported with standard errors, 95% confidence intervals, and sample coverage at observed effort and at double effort."
)
```

```{r}

#| echo: false
library(knitr)

tab_s12 <- read.csv("tables/Table_S12_iNEXT3D_phylogenetic_diversity.csv")

kable(
  tab_s12,
  digits = 3,
  caption = "Table S12. Phylogenetic diversity (PD; meanPD) summary from iNEXT3D across habitats (q = 0, 1, 2; nboot = 500), including coverage and effective lineage estimates under rarefaction/extrapolation."
)
```

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "iNEXT3D diversity analyses (executed on remote server)"



library(phyloseq)
library(dplyr)
library(tidyr)
library(ggplot2)
library(iNEXT.3D)  
library(ape)        
library(knitr)
library(phangorn)


set.seed(1)

## ---- shared habitat labeling ----
labs_map  <- c(forest = "Forest", subparamo = "Subpáramo", paramo = "Páramo")
lvl_order <- c("Forest", "Subpáramo", "Páramo")

relabel_inext <- function(x) {
  # iNEXT3D objects store multiple data.frames with "Assemblage"
  f <- function(df){
    if (!("Assemblage" %in% names(df))) return(df)
    df$Assemblage <- as.character(df$Assemblage)
    df$Assemblage <- labs_map[df$Assemblage]
    df$Assemblage <- factor(df$Assemblage, levels = lvl_order)
    df
  }
  x$TDInfo   <- f(as.data.frame(x$TDInfo))
  x$TDAsyEst <- f(as.data.frame(x$TDAsyEst))
  if (!is.null(x$TDiNextEst)) {
    for (nm in names(x$TDiNextEst)) x$TDiNextEst[[nm]] <- f(as.data.frame(x$TDiNextEst[[nm]]))
  }
  x
}


## =================================================
##  A) TAXONOMIC DIVERSITY (TD)  ---- Table S10 + TD plot
## =================================================

ps_td <- tree_ps

stopifnot(inherits(ps_td, "phyloseq"))

sd <- as.data.frame(sample_data(ps_td))
stopifnot("habitat" %in% names(sd))

# build taxa x samples incidence matrix
OTU <- as(otu_table(ps_td), "matrix")
if (!taxa_are_rows(ps_td)) OTU <- t(OTU)   # taxa x samples

# split samples by habitat
inc_by_hab_td <- lapply(split(rownames(sd), sd$habitat), function(samps){
  M <- OTU[, colnames(OTU) %in% samps, drop = FALSE]
  M[M > 0] <- 1
  storage.mode(M) <- "numeric"
  M
})

# keep only expected habitats and non-empty
inc_by_hab_td <- inc_by_hab_td[names(inc_by_hab_td) %in% names(labs_map)]
inc_by_hab_td <- inc_by_hab_td[vapply(inc_by_hab_td, function(M) nrow(M) > 0 && ncol(M) > 0, TRUE)]
stopifnot(length(inc_by_hab_td) >= 2)

out_TD <- iNEXT3D(
  data      = inc_by_hab_td,
  diversity = "TD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 500
)

# relabel habitat names + ordering for plotting/tables
out_TD <- relabel_inext(out_TD)

# ---- Figure (TD curves) ----
p_TD <- ggiNEXT3D(out_TD, type = 1, facet.var = "Order.q") +
  labs(x = "Sampling units", y = "Taxonomic diversity") +
  theme_minimal(base_size = 14) +
  theme(legend.title = element_blank())

ggsave(
  filename = file.path(out_fig_dir, "Fig_4B_iNEXT3D_TD.png"),
  plot = p_TD, width = 10, height = 6, dpi = 800, bg = "white"
)

# ---- Table S10 (TD summary)
tab_s10 <- as.data.frame(out_TD$TDAsyEst)

# Optional: make “Diversity_order” readable
tab_s10 <- tab_s10 %>%
  mutate(
    Diversity_order = case_when(
      qTD == 0 ~ "Species richness",
      qTD == 1 ~ "Shannon diversity",
      qTD == 2 ~ "Simpson diversity",
      TRUE ~ as.character(qTD)
    )
  ) %>%
  rename(
    Habitat = Assemblage
  )

write.csv(
  tab_s10,
  file.path(out_tab_dir, "Table_S11_iNEXT3D_taxonomic_diversity.csv"),
  row.names = FALSE
)


## ============================================================
##  B) PHYLOGENETIC DIVERSITY (PD) ---- Table S11 + PD plot
## ============================================================

ps_pd <- tree_ps #phyloseq object with phy tree
stopifnot(inherits(ps_pd, "phyloseq"))
stopifnot(!is.null(phy_tree(ps_pd, errorIfNULL = FALSE)))

sd2 <- as.data.frame(sample_data(ps_pd))
stopifnot("habitat" %in% names(sd2))

# Fix mislabel if present
sd2$habitat <- as.character(sd2$habitat)
sd2$habitat[sd2$habitat == "pasture"] <- "forest"
sample_data(ps_pd)$habitat <- factor(sd2$habitat)

# build taxa x samples incidence
X <- as(otu_table(ps_pd), "matrix")
if (!taxa_are_rows(ps_pd)) X <- t(X)  # taxa x samples

sd2 <- as.data.frame(sample_data(ps_pd))

inc_by_hab_pd <- lapply(split(rownames(sd2), sd2$habitat), function(samps){
  M <- X[, colnames(X) %in% samps, drop = FALSE]
  M[M > 0] <- 1
  storage.mode(M) <- "numeric"
  M
})

inc_by_hab_pd <- inc_by_hab_pd[names(inc_by_hab_pd) %in% names(labs_map)]
inc_by_hab_pd <- inc_by_hab_pd[vapply(inc_by_hab_pd, function(M) nrow(M) > 0 && ncol(M) > 0, TRUE)]

# Tree: prune to observed taxa in incidence matrices
tr <- phy_tree(ps_pd)
keep_tips <- intersect(tr$tip.label, unique(unlist(lapply(inc_by_hab_pd, rownames))))
stopifnot(length(keep_tips) >= 2)

tr2 <- ape::keep.tip(tr, keep_tips)
tr2$node.label <- NULL
if (!ape::is.rooted(tr2)) tr2 <- phangorn::midpoint(tr2)

# Align matrices to final tip set (same taxa order)
tipset <- tr2$tip.label
inc_by_hab_pd <- lapply(inc_by_hab_pd, function(M) M[rownames(M) %in% tipset, , drop = FALSE])
inc_by_hab_pd <- inc_by_hab_pd[vapply(inc_by_hab_pd, function(M) nrow(M) > 0 && ncol(M) > 0, TRUE)]

out_PD <- iNEXT3D(
  data      = inc_by_hab_pd,
  diversity = "PD",
  q         = c(0,1,2),
  datatype  = "incidence_raw",
  nboot     = 500,
  PDtree    = tr2,
  PDtype    = "meanPD"
)

# Plot
p_PD <- ggiNEXT3D(out_PD, type = 1, facet.var = "Order.q") +
  labs(x = "Sampling units", y = "Phylogenetic diversity (meanPD)") +
  theme_minimal(base_size = 14) +
  theme(legend.title = element_blank())

ggsave(
  filename = file.path(out_fig_dir, "Fig_4A_iNEXT3D_PD.png"),
  plot = p_PD, width = 10, height = 6, dpi = 800, bg = "white"
)

# Table S11: PD summary lives in $PDAsyEst (same logic as TD)
tab_s11 <- as.data.frame(out_PD$PDAsyEst) %>%
  rename(Habitat = Assemblage)

# Relabel habitats to capitalized versions (same mapping)
tab_s11$Habitat <- as.character(tab_s11$Habitat)
tab_s11$Habitat <- labs_map[tab_s11$Habitat]
tab_s11$Habitat <- factor(tab_s11$Habitat, levels = lvl_order)

write.csv(
  tab_s11,
  file.path(out_tab_dir, "Table_S12_iNEXT3D_phylogenetic_diversity.csv"),
  row.names = FALSE
)


```

## Nearest Taxon Index (NTI) and Net Relatedness Index (NRI)

Phylogenetic community structure was quantified using Net Relatedness Index (NRI; based on MPD) and Nearest Taxon Index (NTI; based on MNTD), calculated under a taxa-label null model with 999 randomizations using both abundance-weighted (aw) and presence–absence (pa) versions. Habitat-level summaries are reported as median (IQR) (Table S13). Habitat and site effects on abundance-weighted metrics were evaluated with linear models (habitat + site; Table S14). Model diagnostics for the NTI_aw model are available in Fig. S10.

```{r}
#| echo: false
library(knitr)

tab_s13 <- read.csv("tables/Table_S13_NRI_NTI_median_IQR.csv")
kable(tab_s13,
      caption = "Table S13. Median (IQR) of NRI and NTI across habitats, calculated using abundance-weighted (aw) and presence–absence (pa) metrics. Positive values indicate phylogenetic clustering relative to null expectations.")
```

```{r}
#| echo: false
library(knitr)

tab_s14 <- read.csv("tables/Table_S14_NRI_NTI_ANOVA.csv")
kable(tab_s14, digits = 4,
      caption = "Table S14. ANOVA summaries for linear models of abundance-weighted NTI and NRI (habitat + site).")
```

![](figures/Fig_S11_NTI_aw_diagnostics.png)

**Figure S10**: Diagnostic plots for the NTI_aw linear model.

```{r}
#| eval: false
#| echo: true
#| code-fold: true
#| code-summary: "NTI/NRI computation + summaries (executed on remote server)"

# Key outputs saved:
#   - figures/Fig_S10_NTI_aw_diagnostics.png
#   - tables/Table_S13_NRI_NTI_median_IQR.csv
#   - tables/Table_S14_NRI_NTI_ANOVA.csv

library(phyloseq)
library(picante)
library(ape)
library(phangorn)
library(dplyr)
library(ggplot2)
library(patchwork)

set.seed(1)

ps <- ps_tree #phyloseq object with tree

stopifnot(exists("ps"))
tr2 <- phy_tree(ps)
stopifnot(!is.null(tr2))

# Root tree if needed
if (!ape::is.rooted(tr2)) tr2 <- phangorn::midpoint(tr2)

## 1) samples x taxa abundance matrix
comm <- as(otu_table(ps), "matrix")
if (taxa_are_rows(ps)) comm <- t(comm)

## 2) align taxa with tree tips
keep_taxa <- intersect(colnames(comm), tr2$tip.label)
comm <- comm[, keep_taxa, drop = FALSE]
tr2  <- ape::keep.tip(tr2, keep_taxa)

## 3) optional: drop ultra-rare taxa 
min_total_taxon_reads <- 10
keep_taxa2 <- colSums(comm) >= min_total_taxon_reads
comm <- comm[, keep_taxa2, drop = FALSE]
tr2  <- ape::keep.tip(tr2, colnames(comm))

## 4) metadata aligned to comm
md <- as(sample_data(ps), "data.frame")
md <- md[rownames(comm), , drop = FALSE]
md$habitat <- droplevels(factor(md$habitat))
md$site    <- droplevels(factor(md$site))

## 5) phylogenetic distances among taxa
dist_phy <- cophenetic(tr2)

## 6) null model tests
mpd_aw  <- ses.mpd (comm, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = TRUE)
mntd_aw <- ses.mntd(comm, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = TRUE)

comm_pa <- 1 * (comm > 0)
mpd_pa  <- ses.mpd (comm_pa, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = FALSE)
mntd_pa <- ses.mntd(comm_pa, dist_phy, null.model = "taxa.labels",
                    runs = 999, abundance.weighted = FALSE)

## 7) per-sample output table
out <- data.frame(
  sample = rownames(comm),
  NRI_aw = -mpd_aw$mpd.obs.z,
  NTI_aw = -mntd_aw$mntd.obs.z,
  NRI_pa = -mpd_pa$mpd.obs.z,
  NTI_pa = -mntd_pa$mntd.obs.z,
  stringsAsFactors = FALSE
)
rownames(out) <- out$sample

# Drop any sample with NA (e.g., too few taxa after filtering)
out <- out[complete.cases(out[, c("NRI_aw","NTI_aw","NRI_pa","NTI_pa")]), ]
out <- cbind(out, md[rownames(out), c("habitat","site"), drop = FALSE])
out$habitat <- droplevels(factor(out$habitat))
out$site    <- droplevels(factor(out$site))

## 8) Table S12: median (IQR) per habitat, formatted as "median (IQR)"
fmt_med_iqr <- function(x) sprintf("%.3f (%.2f)", median(x, na.rm=TRUE), IQR(x, na.rm=TRUE))

tab_s12 <- out %>%
  group_by(habitat) %>%
  summarise(
    n = n(),
    NRI_aw = fmt_med_iqr(NRI_aw),
    NTI_aw = fmt_med_iqr(NTI_aw),
    NRI_pa = fmt_med_iqr(NRI_pa),
    NTI_pa = fmt_med_iqr(NTI_pa),
    .groups = "drop"
  ) %>%
  rename(Habitat = habitat)

write.csv(tab_s12, file.path(out_tab_dir, "Table_S13_NRI_NTI_median_IQR.csv"), row.names = FALSE)

## 9) Table S13: ANOVA summaries (NTI_aw and NRI_aw models)
m_NTI_aw <- lm(NTI_aw ~ habitat + site, data = out)
m_NRI_aw <- lm(NRI_aw ~ habitat + site, data = out)

a_NTI <- as.data.frame(anova(m_NTI_aw))
a_NRI <- as.data.frame(anova(m_NRI_aw))

tab_s13 <- bind_rows(
  data.frame(Response = "NTI_aw", Predictor = rownames(a_NTI), df = a_NTI$Df, F = a_NTI$`F value`, p = a_NTI$`Pr(>F)`),
  data.frame(Response = "NRI_aw", Predictor = rownames(a_NRI), df = a_NRI$Df, F = a_NRI$`F value`, p = a_NRI$`Pr(>F)`)
) %>%
  filter(Predictor %in% c("habitat","site","Residuals"))

write.csv(tab_s13, file.path(out_tab_dir, "Table_S14_NRI_NTI_ANOVA.csv"), row.names = FALSE)

## 10) Figure S11: diagnostics for NTI_aw model
diagdf <- data.frame(
  fitted = fitted(m_NTI_aw),
  resid  = resid(m_NTI_aw),
  stdres = rstandard(m_NTI_aw),
  cooks  = cooks.distance(m_NTI_aw),
  hat    = hatvalues(m_NTI_aw)
)

p1 <- ggplot(diagdf, aes(fitted, resid)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_point(alpha = 0.7, size = 1.8) +
  geom_smooth(method = "loess", se = FALSE, linewidth = 0.5) +
  labs(x = "Fitted values", y = "Residuals", title = "Residuals vs fitted") +
  theme_bw(base_size = 10)

p2 <- ggplot(diagdf, aes(sample = stdres)) +
  stat_qq(alpha = 0.7, size = 1.5) +
  stat_qq_line() +
  labs(title = "Normal Q–Q (standardized residuals)") +
  theme_bw(base_size = 10)

p3 <- ggplot(diagdf, aes(seq_along(cooks), cooks)) +
  geom_point(alpha = 0.7, size = 1.8) +
  geom_hline(yintercept = 0.5, linetype = "dashed") +
  labs(x = "Observation index", y = "Cook's distance", title = "Influence (Cook's distance)") +
  theme_bw(base_size = 10)

p4 <- ggplot(diagdf, aes(seq_along(hat), hat)) +
  geom_point(alpha = 0.7, size = 1.8) +
  labs(x = "Observation index", y = "Leverage (hat)", title = "Leverage") +
  theme_bw(base_size = 10)

panel <- (p1 | p2) / (p3 | p4) + plot_annotation(title = "NTI_aw model diagnostics")

ggsave(
  filename = file.path(out_fig_dir, "Fig_S10_NTI_aw_diagnostics.png"),
  plot = panel,
  width = 10, height = 7, dpi = 600, bg = "white"
)
```

## Soil Physicochemical parameters

To provide environmental context for the elevational gradients sampled in this study, we quantified bulk soil physicochemical properties from one composite topsoil sample (0–15 cm) collected at each sampling location (n = 12; one per location). Because soil chemistry was measured once per location, these data are interpreted descriptively and were not used for formal statistical inference among habitats or sites.

The full soil dataset, including all measured variables, is provided as Table S15 and is archived in the repository as "Data_S3_soil.csv".

![](figures/FigS12_soil.png)\
\
**Figure S11**: Correlation heatmap of bulk soil physicochemical variables measured at each sampling location (n = 12). Colors indicate Pearson correlation among soil variables and elevation.
